package com.saveourtool.cosv.backend.controllers

import com.saveourtool.common.configs.ApiSwaggerSupport
import com.saveourtool.common.configs.RequiresAuthorizationSourceHeader
import com.saveourtool.common.domain.Role
import com.saveourtool.common.entities.cosv.VulnerabilityExt
import com.saveourtool.common.entities.cosv.VulnerabilityMetadataDto
import com.saveourtool.common.entities.vulnerability.VulnerabilityDateDto
import com.saveourtool.common.entities.vulnerability.VulnerabilityProjectDto
import com.saveourtool.common.entities.vulnerability.VulnerabilityStatus
import com.saveourtool.common.filters.VulnerabilityFilter
import com.saveourtool.common.info.UserInfo
import com.saveourtool.common.permission.Permission
import com.saveourtool.common.service.UserService
import com.saveourtool.common.utils.*
import com.saveourtool.common.v1
import com.saveourtool.cosv.backend.security.VulnerabilityPermissionEvaluator
import com.saveourtool.cosv.backend.service.CosvService
import com.saveourtool.cosv.backend.service.VulnerabilityMetadataDtoList
import com.saveourtool.cosv.backend.service.VulnerabilityService
import com.saveourtool.cosv.backend.utils.hasRole
import com.saveourtool.save.authservice.utils.username

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import io.swagger.v3.oas.annotations.tags.Tags
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.Authentication
import org.springframework.web.bind.annotation.*
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

/**
 * Controller for working with vulnerabilities.
 */
@ApiSwaggerSupport
@Tags(
    Tag(name = "vulnerabilities"),
)
@RestController
@RequestMapping(path = ["/api/$v1/vulnerabilities"])
class VulnerabilityController(
    private val vulnerabilityService: VulnerabilityService,
    private val vulnerabilityPermissionEvaluator: VulnerabilityPermissionEvaluator,
    private val cosvService: CosvService,
    private val userService: UserService,
) {
    @PostMapping("/by-filter")
    @Operation(
        method = "POST",
        summary = "Get all vulnerabilities with filters.",
        description = "Get filtered vulnerabilities.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched all vulnerabilities by filters")
    fun getAllVulnerabilities(
        @RequestParam page: Int,
        @RequestParam size: Int,
        @RequestBody filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): Mono<VulnerabilityMetadataDtoList> = blockingToMono {
        checkPermission(filter, authentication)
        vulnerabilityService.getFilteredWithUserInfos(filter, page, size)
    }

    @PostMapping("/count/by-filter")
    @Operation(
        method = "POST",
        summary = "Get all vulnerabilities with filters.",
        description = "Get filtered vulnerabilities.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched all vulnerabilities by filters")
    fun getCountVulnerabilities(
        @RequestBody filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): Mono<Long> = blockingToMono {
        checkPermission(filter, authentication)
        vulnerabilityService.getCountVulnerabilitiesByFilter(filter)
    }

    private fun checkPermission(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ) {
        /* Everyone has permission to public vulnerabilities (that have status APPROVED or AUTO_APPROVED), also permission have:
           1) super admins to all vulnerabilities;
           2) users to their vulnerabilities;
           3) users to organization vulnerabilities in which they have ADMIN role or higher; */
        val isPublicVulnerabilities = filter.statuses?.isNotEmpty() == true &&
                filter.statuses?.all { it in listOf(VulnerabilityStatus.APPROVED, VulnerabilityStatus.AUTO_APPROVED) } == true

        if (!isPublicVulnerabilities && authentication != null) {
            val isSuperAdmin = authentication.hasRole(Role.SUPER_ADMIN)
            val isOwner = filter.authorName?.let { it == authentication.username() } ?: false
            val roleInOrganization = filter.organizationName?.let { userService.getGlobalRoleOrOrganizationRole(authentication, it) }
            val isAdminInOrganization = roleInOrganization?.isHigherOrEqualThan(Role.ADMIN) ?: false

            val isHasAdditionalRights = isSuperAdmin || isOwner || isAdminInOrganization

            if (!isHasAdditionalRights) {
                throw ResponseStatusException(HttpStatus.FORBIDDEN)
            }
        } else if (!isPublicVulnerabilities) {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }

    @GetMapping("/by-identifier")
    @Operation(
        method = "GET",
        summary = "Get vulnerability by identifier.",
        description = "Get vulnerability by identifier.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched vulnerability by identifier")
    fun getVulnerabilityByIdentifierAndActive(
        @RequestParam identifier: String,
    ): Mono<VulnerabilityMetadataDto> = blockingToMono { vulnerabilityService.findByName(identifier) }
        .switchIfEmptyToNotFound()

    @GetMapping("/by-identifier-with-description")
    @Operation(
        method = "GET",
        summary = "Get vulnerability by identifier with description.",
        description = "Get vulnerability by identifier with description.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "Successfully fetched vulnerability by identifier with description"
    )
    fun getVulnerabilityWithDescriptionByIdentifier(
        @RequestParam identifier: String,
    ): Mono<VulnerabilityExt> = vulnerabilityService.getVulnerabilityWithDescriptionByIdentifier(identifier)
        .switchIfEmptyToNotFound { "Could not find vulnerability with identifier $identifier" }

    @GetMapping("/count-by-user")
    @Operation(
        method = "GET",
        summary = "Get cont of vulnerabilities by user name.",
        description = "Get cont of vulnerabilities by user name.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched cont of vulnerabilities by user name")
    fun getCountVulnerabilityByUser(
        @RequestParam userName: String,
    ): Mono<Int> = blockingToMono {
        vulnerabilityService.countByUserNameAndStatus(userName, VulnerabilityStatus.APPROVED)
    }

    @GetMapping("/user-in-vulnerability")
    @Operation(
        method = "GET",
        summary = "Get list of user by vulnerability identifier.",
        description = "Get list of user by vulnerability identifier.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched list of user by vulnerability identifier")
    fun getUserInVulnerabilityByVulnerabilityId(
        @RequestParam identifier: String,
    ): Flux<UserInfo> = blockingToFlux {
        vulnerabilityService.findUsersByVulnerabilityId(identifier)
    }.switchIfEmptyToNotFound()

    @GetMapping("/download")
    @Operation(
        method = "GET",
        summary = "Download vulnerability in COSV.",
        description = "Download vulnerability in COSV.",
    )
    @ApiResponse(responseCode = "200", description = "Content of vulnerability in COSV format")
    fun download(
        @RequestParam identifier: String,
        authentication: Authentication?,
    ): Mono<ByteBufferFluxResponse> = identifier.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.READ)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) {
            "${authentication?.name ?: "no-user"} doesn't have access to $identifier"
        }
        .map {
            ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"$it.json\"")
                .body(cosvService.getVulnerabilityAsCosvStream(it))
        }

    @PostMapping("/update")
    @Operation(
        method = "POST",
        summary = "Update vulnerability.",
        description = "Update vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully updated vulnerability")
    @RequiresAuthorizationSourceHeader
    fun update(
        @RequestBody vulnerabilityExt: VulnerabilityExt,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityService.update(vulnerabilityExt, authentication).map {
        ResponseEntity.ok("Vulnerability was successfully updated")
    }

    @PostMapping("/approve")
    @Operation(
        method = "POST",
        summary = "Approve vulnerability.",
        description = "Approve vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully approve vulnerability")
    @RequiresAuthorizationSourceHeader
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    fun approve(
        @RequestParam identifier: String,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.approve(identifier)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully approve")
    }

    @PostMapping("/reject")
    @Operation(
        method = "POST",
        summary = "Reject vulnerability.",
        description = "Reject vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully rejected vulnerability")
    @RequiresAuthorizationSourceHeader
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    fun reject(
        @RequestParam identifier: String,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.reject(identifier)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully rejected")
    }

    @DeleteMapping("/delete")
    @Operation(
        method = "Delete",
        summary = "Deleted vulnerability.",
        description = "Deleted vulnerability by its identifier.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully deleted vulnerability")
    @RequiresAuthorizationSourceHeader
    fun delete(
        @RequestParam identifier: String,
        authentication: Authentication,
    ): Mono<StringResponse> =
            identifier.toMono()
                .filter {
                    vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
                }
                .map { vulnerabilityService.delete(identifier) }
                .flatMapMany { vulnerabilityService.deleteAllVersions(identifier) }
                .thenJust(
                    ResponseEntity.ok("Vulnerability $identifier was successfully deleted")
                )

    @PostMapping("/to-review")
    @Operation(
        method = "POST",
        summary = "Mark vulnerability as ready for review.",
        description = "Mark vulnerability as ready for review.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully sent vulnerability for review")
    @RequiresAuthorizationSourceHeader
    fun toReview(
        @RequestParam identifier: String,
        authentication: Authentication,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.sendToReview(identifier, authentication)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully sent for review")
    }

    @PostMapping("/save-projects")
    @Operation(
        method = "POST",
        summary = "Save new projects.",
        description = "Save new projects.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully saved new projects in vulnerability")
    fun saveAllProjects(
        @RequestBody vulnerabilityDtos: List<VulnerabilityProjectDto>,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityDtos.first()
        .vulnerabilityIdentifier
        .toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.saveAllProjects(vulnerabilityDtos) } }
        .map {
            ResponseEntity.ok("Projects were successfully saved in vulnerability")
        }

    @PostMapping("/save-date")
    @Operation(
        method = "POST",
        summary = "Save new date.",
        description = "Save new date.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully saved new date in vulnerability")
    @ApiResponse(responseCode = "404", description = "Could not either find user or find vulnerability")
    @ApiResponse(responseCode = "409", description = "Could not save date as it is already present in vulnerability")
    fun saveDate(
        @RequestBody vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityDateDto.vulnerabilityIdentifier.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { vulnerabilityService.saveDate(vulnerabilityDateDto) }
        .switchIfErrorToConflict {
            "Date with type ${vulnerabilityDateDto.type} is already present in ${vulnerabilityDateDto.vulnerabilityIdentifier} vulnerability"
        }
        .map { ResponseEntity.ok("Date was successfully saved in vulnerability") }

    @DeleteMapping("/delete-project")
    @Operation(
        method = "Delete",
        summary = "Delete project.",
        description = "Delete project.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully deleted project from vulnerability")
    fun deleteProject(
        @RequestParam projectName: String,
        @RequestParam identifier: String,
        authentication: Authentication,
    ): Mono<StringResponse> = identifier.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.deleteProject(projectName, it) } }
        .map {
            ResponseEntity.ok("Project $projectName was successfully deleted from vulnerability $identifier")
        }

    @PostMapping("/save-user")
    @Operation(
        method = "POST",
        summary = "Save new date.",
        description = "Save new date.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully saved new user in vulnerability")
    @ApiResponse(responseCode = "404", description = "Could not either find user or find vulnerability")
    @ApiResponse(responseCode = "409", description = "Could not save user as it is already present in vulnerability")
    fun saveUser(
        @RequestBody userName: String,
        @RequestBody identifier: String,
        authentication: Authentication,
    ): Mono<StringResponse> = identifier.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { vulnerabilityService.saveUser(userName, it) }
        .switchIfErrorToConflict {
            "User with name $userName is already present in $identifier vulnerability"
        }
        .map { ResponseEntity.ok("User was successfully saved in vulnerability") }

    @DeleteMapping("/delete-user")
    @Operation(
        method = "DELETE",
        summary = "Delete user.",
        description = "Delete user.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully deleted user from vulnerability")
    @ApiResponse(responseCode = "404", description = "Requested user is not found")
    fun deleteUser(
        @RequestBody userName: String,
        @RequestBody identifier: String,
        authentication: Authentication,
    ): Mono<StringResponse> = identifier.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.deleteUser(userName, it) } }
        .switchIfEmptyToNotFound { "Could not find user." }
        .map { ResponseEntity.ok("Successfully deleted user from vulnerability.") }
}
