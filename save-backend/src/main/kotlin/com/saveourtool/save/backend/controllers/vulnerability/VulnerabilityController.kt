package com.saveourtool.save.backend.controllers.vulnerability

import com.saveourtool.save.backend.security.VulnerabilityPermissionEvaluator
import com.saveourtool.save.backend.service.vulnerability.VulnerabilityService
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.configs.ApiSwaggerSupport
import com.saveourtool.save.configs.RequiresAuthorizationSourceHeader
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.vulnerabilities.Vulnerability
import com.saveourtool.save.entities.vulnerability.VulnerabilityDateDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityProjectDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityStatus
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.permission.Permission
import com.saveourtool.save.utils.*
import com.saveourtool.save.v1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import io.swagger.v3.oas.annotations.tags.Tags
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.Authentication
import org.springframework.web.bind.annotation.*
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

typealias VulnerabilityDtoList = List<VulnerabilityDto>

/**
 * Controller for working with vulnerabilities.
 */
@ApiSwaggerSupport
@Tags(
    Tag(name = "vulnerabilities"),
)
@RestController
@RequestMapping(path = ["/api/$v1/vulnerabilities"])
class VulnerabilityController(
    private val vulnerabilityService: VulnerabilityService,
    private val vulnerabilityPermissionEvaluator: VulnerabilityPermissionEvaluator,
) {
    @PostMapping("/by-filters")
    @Operation(
        method = "POST",
        summary = "Get all vulnerabilities with filters.",
        description = "Get filtered vulnerabilities.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched all vulnerabilities by filters")
    fun getAllVulnerabilities(
        @RequestBody filters: VulnerabilityFilter,
        authentication: Authentication?,
    ): Mono<VulnerabilityDtoList> = blockingToMono {
        if (authentication?.hasRole(Role.SUPER_ADMIN) != true && filters.status != VulnerabilityStatus.APPROVED && !filters.isOwner) {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
        vulnerabilityService.getFiltered(filters, authentication).map(Vulnerability::toDto)
    }

    @PostMapping("/get-all-public")
    @Operation(
        method = "GET",
        summary = "Get all public vulnerabilities.",
        description = "Get all public vulnerabilities.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched all public vulnerabilities.")
    fun getAllPublicVulnerabilities(
        @RequestBody filters: VulnerabilityFilter,
    ): Flux<VulnerabilityDto> = blockingToFlux {
        vulnerabilityService.getFiltered(filters).map(Vulnerability::toDto)
    }

    @GetMapping("/by-name-and-status")
    @Operation(
        method = "GET",
        summary = "Get vulnerability by name.",
        description = "Get vulnerability by name.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched vulnerability by name")
    fun getVulnerabilityByNameAndActive(
        @RequestParam name: String,
        @RequestParam status: VulnerabilityStatus,
    ): Mono<VulnerabilityDto> = blockingToMono {
        vulnerabilityService.findByNameAndStatus(name, status)?.toDto()
    }.switchIfEmptyToNotFound()

    @GetMapping("/by-id-name-and-status")
    @Operation(
        method = "GET",
        summary = "Get vulnerability by vulnerabilityIdentifier.",
        description = "Get vulnerability by vulnerabilityIdentifier.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched vulnerability by vulnerabilityIdentifier")
    fun getVulnerabilityByVulnerabilityIdentifierAndStatus(
        @RequestParam vulnerabilityIdentifier: String,
        @RequestParam status: VulnerabilityStatus,
    ): Mono<VulnerabilityDto> = blockingToMono {
        vulnerabilityService.findByVulnerabilityIdentifierAndStatus(vulnerabilityIdentifier, status)?.toDto()
    }.switchIfEmptyToNotFound()

    @GetMapping("/by-name-with-description")
    @Operation(
        method = "GET",
        summary = "Get vulnerability by name with description.",
        description = "Get vulnerability by name with description.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched vulnerability by name with description")
    fun getVulnerabilityWithDescriptionByName(
        @RequestParam name: String,
    ): Mono<VulnerabilityDto> = blockingToMono {
        vulnerabilityService.getVulnerabilityWithDescriptionByName(name)
    }.switchIfEmptyToNotFound { "Could not find vulnerability with name $name" }

    @GetMapping("/by-user-and-status")
    @Operation(
        method = "GET",
        summary = "Get list of vulnerabilities by user id.",
        description = "Get list of vulnerabilities by user id.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched list of vulnerabilities by user id")
    fun getVulnerabilityByUser(
        @RequestParam userName: String,
        @RequestParam status: VulnerabilityStatus,
    ): Flux<VulnerabilityDto> = blockingToFlux {
        vulnerabilityService.findByUserNameAndStatus(userName, status).map { it.toDto() }
    }.switchIfEmptyToNotFound()

    @GetMapping("/by-organization-and-status")
    @Operation(
        method = "GET",
        summary = "Get list of vulnerabilities by organization name.",
        description = "Get list of vulnerabilities by organization name.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched list of vulnerabilities by organization name")
    fun getVulnerabilityByOrganization(
        @RequestParam organizationName: String,
        @RequestParam status: VulnerabilityStatus,
    ): Flux<VulnerabilityDto> = blockingToFlux {
        vulnerabilityService.findByOrganizationNameAndStatus(organizationName, status).map { it.toDto() }
    }.switchIfEmptyToNotFound()

    @GetMapping("/user-in-vulnerability")
    @Operation(
        method = "GET",
        summary = "Get list of user by vulnerability id.",
        description = "Get list of user by vulnerability id.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully fetched list of user by vulnerability id")
    fun getUserInVulnerabilityByVulnerabilityId(
        @RequestParam vulnerabilityId: Long,
    ): Flux<UserInfo> = blockingToFlux {
        vulnerabilityService.findUsersByVulnerabilityId(vulnerabilityId).map { it.user.toUserInfo() }
    }.switchIfEmptyToNotFound()

    @PostMapping("/save")
    @Operation(
        method = "POST",
        summary = "Save vulnerability.",
        description = "Save vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully saved vulnerability")
    @PreAuthorize("permitAll()")
    fun save(
        @RequestBody vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.save(vulnerabilityDto, authentication)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully saved")
    }

    @PostMapping("/save-all")
    @Operation(
        method = "POST",
        summary = "Save all vulnerabilities.",
        description = "Save all vulnerabilities.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully saved all vulnerabilities")
    @PreAuthorize("permitAll()")
    fun saveAll(
        @RequestBody vulnerabilityDtos: List<VulnerabilityDto>,
        authentication: Authentication,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.saveAll(vulnerabilityDtos, authentication)
    }.map {
        ResponseEntity.ok("All vulnerabilities were successfully saved")
    }

    @PostMapping("/update")
    @Operation(
        method = "POST",
        summary = "Update vulnerability.",
        description = "Update vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully updated vulnerability")
    @RequiresAuthorizationSourceHeader
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    fun update(
        @RequestBody vulnerabilityDto: VulnerabilityDto,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.update(vulnerabilityDto)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully updated")
    }

    @PostMapping("/approve")
    @Operation(
        method = "POST",
        summary = "Approve vulnerability.",
        description = "Approve vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully approve vulnerability")
    @RequiresAuthorizationSourceHeader
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    fun approve(
        @RequestBody vulnerabilityDto: VulnerabilityDto,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.approve(vulnerabilityDto)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully approve")
    }

    @DeleteMapping("/delete")
    @Operation(
        method = "Delete",
        summary = "Deleted vulnerability.",
        description = "Deleted vulnerability.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully deleted vulnerability")
    @RequiresAuthorizationSourceHeader
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    fun delete(
        @RequestParam name: String,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.delete(name)
    }.map {
        ResponseEntity.ok("Vulnerability was successfully deleted")
    }

    @PostMapping("/save-projects")
    @Operation(
        method = "POST",
        summary = "Save new projects.",
        description = "Save new projects.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully saved new projects in vulnerability")
    fun saveAllProjects(
        @RequestBody vulnerabilityDtos: List<VulnerabilityProjectDto>,
    ): Mono<StringResponse> = blockingToMono {
        vulnerabilityService.saveAllProjects(vulnerabilityDtos)
    }.map {
        ResponseEntity.ok("Projects were successfully saved in vulnerability")
    }

    @PostMapping("/save-date")
    @Operation(
        method = "POST",
        summary = "Save new date.",
        description = "Save new date.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully saved new date in vulnerability")
    @ApiResponse(responseCode = "404", description = "Could not either find user or find vulnerability")
    @ApiResponse(responseCode = "409", description = "Could not save date as it is already present in vulnerability")
    fun saveDate(
        @RequestBody vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityDateDto.vulnerabilityName.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.saveDate(vulnerabilityDateDto, authentication) } }
        .switchIfErrorToConflict {
            "Date with type ${vulnerabilityDateDto.type} is already present in ${vulnerabilityDateDto.vulnerabilityName} vulnerability"
        }
        .map { ResponseEntity.ok("Date was successfully saved in vulnerability") }

    @PostMapping("/delete-date")
    @Operation(
        method = "POST",
        summary = "Delete date.",
        description = "Delete date.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully deleted date from vulnerability")
    @ApiResponse(responseCode = "404", description = "Requested date is not found")
    @Suppress("UnusedParameter")
    fun deleteDate(
        @RequestBody vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityDateDto.vulnerabilityName.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, it, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.deleteDate(vulnerabilityDateDto) } }
        .map { ResponseEntity.ok("Date was successfully deleted from vulnerability") }

    @DeleteMapping("/delete-project")
    @Operation(
        method = "Delete",
        summary = "Delete project.",
        description = "Delete project.",
    )
    @ApiResponse(responseCode = "200", description = "Successfully deleted project from vulnerability")
    fun deleteProject(
        @RequestParam projectName: String,
        @RequestParam vulnerabilityName: String,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityName.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, vulnerabilityName, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.deleteProject(projectName, vulnerabilityName) } }
        .map {
            ResponseEntity.ok("Project $projectName was successfully deleted from vulnerability $vulnerabilityName")
        }

    @PostMapping("/save-user")
    @Operation(
        method = "POST",
        summary = "Save new date.",
        description = "Save new date.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully saved new user in vulnerability")
    @ApiResponse(responseCode = "404", description = "Could not either find user or find vulnerability")
    @ApiResponse(responseCode = "409", description = "Could not save user as it is already present in vulnerability")
    fun saveUser(
        @RequestBody userName: String,
        @RequestBody vulnerabilityName: String,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityName.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, vulnerabilityName, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.saveUser(userName, vulnerabilityName) } }
        .switchIfErrorToConflict {
            "User with name $userName is already present in $vulnerabilityName vulnerability"
        }
        .map { ResponseEntity.ok("User was successfully saved in vulnerability") }

    @DeleteMapping("/delete-user")
    @Operation(
        method = "DELETE",
        summary = "Delete user.",
        description = "Delete user.",
    )
    @PreAuthorize("permitAll()")
    @ApiResponse(responseCode = "200", description = "Successfully deleted user from vulnerability")
    @ApiResponse(responseCode = "404", description = "Requested user is not found")
    fun deleteUser(
        @RequestBody userName: String,
        @RequestBody vulnerabilityName: String,
        authentication: Authentication,
    ): Mono<StringResponse> = vulnerabilityName.toMono()
        .filter {
            vulnerabilityPermissionEvaluator.hasPermission(authentication, vulnerabilityName, Permission.DELETE)
        }
        .switchIfEmptyToResponseException(HttpStatus.FORBIDDEN) { "Permissions required for comment deletion were not granted." }
        .flatMap { blockingToMono { vulnerabilityService.deleteUser(userName, vulnerabilityName) } }
        .switchIfEmptyToNotFound { "Could not find user." }
        .map { StringResponse.ok("Successfully deleted user from vulnerability.") }
}
