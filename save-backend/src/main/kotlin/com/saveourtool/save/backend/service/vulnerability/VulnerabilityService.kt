package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.OrganizationRepository
import com.saveourtool.save.backend.repository.TagRepository
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.cosv.repository.*
import com.saveourtool.save.cosv.service.CosvService
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.Tag
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.*
import com.saveourtool.save.entities.vulnerability.*
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.*

import org.springframework.data.domain.PageRequest
import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

import javax.persistence.criteria.*

import kotlinx.datetime.LocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
@Suppress("LongParameterList")
class VulnerabilityService(
    private val vulnerabilityMetadataProjectRepository: VulnerabilityMetadataProjectRepository,
    private val lnkVulnerabilityMetadataUserRepository: LnkVulnerabilityMetadataUserRepository,
    private val userRepository: UserRepository,
    private val organizationRepository: OrganizationRepository,
    private val cosvService: CosvService,
    private val cosvRepository: CosvRepository,
    private val vulnerabilityMetadataRepository: VulnerabilityMetadataRepository,
    private val lnkVulnerabilityMetadataTagRepository: LnkVulnerabilityMetadataTagRepository,
    private val tagRepository: TagRepository,
    private val vulnerabilityGeneratedIdRepository: VulnerabilityGeneratedIdRepository,
) {
    private fun List<VulnerabilityMetadata>.toTagMap() = lnkVulnerabilityMetadataTagRepository.findByVulnerabilityMetadataIdIn(this.map { it.requiredId() })
        .map { link -> link.vulnerabilityMetadata to link.tag }
        .groupBy { (metadata, _) -> metadata }
        .mapValues { (_, list) -> list.map { it.second }.toSet() }

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = vulnerabilityMetadataRepository.findByIdentifier(name)?.toDto()?.toVulnerabilityDto()

    /**
     * @param userName creator of vulnerability
     * @return list of vulnerabilities
     */
    fun findByUserNameAndStatus(userName: String): List<VulnerabilityDto> {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityMetadataRepository.findByUserId(user.requiredId()).map { it.toDto().toVulnerabilityDto() }
    }

    /**
     * @param userName
     * @param status
     * @return count of vulnerabilities
     */
    fun countByUserNameAndStatus(userName: String, status: VulnerabilityStatus): Int {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityMetadataRepository.countByUserIdAndStatus(user.requiredId(), status)
    }

    /**
     * @param organizationName name of organization
     * @param status status of vulnerability
     * @return list of vulnerabilities
     */
    fun findByOrganizationNameAndStatus(organizationName: String, status: VulnerabilityStatus): List<VulnerabilityDto> =
            vulnerabilityMetadataRepository.findByOrganizationNameAndStatus(organizationName, status).map { it.toDto().toVulnerabilityDto() }

    /**
     * @param identifier id of vulnerability
     * @return list of vulnerabilities
     */
    fun findUsersByVulnerabilityId(
        identifier: String
    ): List<UserInfo> = vulnerabilityMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId()).map { it.user.toUserInfo() }
        }

    /**
     * @param filter filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @param page
     * @param size
     * @return list of vulnerabilities with that match [filter]
     */
    @Suppress(
        "TOO_LONG_FUNCTION",
        "LongMethod",
        "CyclomaticComplexMethod",
    )
    fun getFilteredWithUserInfos(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
        page: Int,
        size: Int,
    ): List<VulnerabilityMetadataDto> {
        val metadataList = vulnerabilityMetadataRepository.findAll({ root, cq, cb -> getFilterPredicate(root, cq, cb, filter, authentication) },
            PageRequest.of(page, size)
        )

        val tagMap = metadataList.content.toTagMap()
        return metadataList.content.map { metadata -> metadata to tagMap[metadata].orEmpty() }
            .map { (metadata, tags) ->
                metadata.toDto().copy(
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param filter
     * @param authentication
     * @return count of vulnerability
     */
    fun getCountVulnerabilitiesByFilter(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ) = vulnerabilityMetadataRepository.count { root, cq, cb -> getFilterPredicate(root, cq, cb, filter, authentication) }

    private fun getFilterPredicate(
        root: Root<VulnerabilityMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): Predicate {
        with(filter) {
            val namePredicate = if (identifierPrefix.isBlank()) {
                cb.and()
            } else {
                cb.like(root.get("identifier"), "%$identifierPrefix%")
            }

            val ownerPredicate = authentication?.let {
                val userId = authentication.userId()

                if (isOwner) {
                    cb.equal(root.get<User>("user").get<Long>("id"), userId)
                } else {
                    cb.and()
                }
            } ?: cb.and()

            val statusPredicate = statuses?.let { statuses ->
                cb.and(root.get<VulnerabilityStatus>("status").`in`(statuses))
            } ?: cb.and()

            val languagePredicate = language?.let { language ->
                cb.equal(root.get<VulnerabilityLanguage>("language"), language)
            } ?: cb.and()

            val organizationPredicate = organizationName?.let { organization ->
                cb.equal(root.get<Organization>("organization").get<String>("name"), organization)
            } ?: cb.and()

            val authorPredicate = authorName?.let { author ->
                cb.equal(root.get<User>("user").get<String>("name"), author)
            } ?: cb.and()

            return cb.and(
                namePredicate,
                ownerPredicate,
                statusPredicate,
                languagePredicate,
                authorPredicate,
                organizationPredicate,
                getPredicateForTags(root, cq, cb, tags),
            )
        }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByIdentifier(name: String): Mono<VulnerabilityDto> =
            cosvService.getVulnerabilityExt(name)
                .blockingMap { rawCosvExt ->
                    rawCosvExt to lnkVulnerabilityMetadataTagRepository.findAllByVulnerabilityMetadataIdentifier(rawCosvExt.metadata.identifier)
                }
                .map { (rawCosvExt, tags) ->
                    val severity = rawCosvExt.cosv.severity?.firstOrNull()?.score.orEmpty()

                    rawCosvExt.toVulnerabilityDtoWithDescription()
                        .copy(
                            dates = rawCosvExt.cosv.getTimeline(),
                            // FixMe: participants should be from a diffirent type to UserInfo
                            // FixMe: participants should also contain credits constructed from OSV/COSV credits field
                            participants = rawCosvExt.saveContributors,
                            userInfo = rawCosvExt.metadata.user,
                            tags = tags.map { it.tag.name }.toSet(),
                            severity = severity,
                        )
                }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     * @return saved [VulnerabilityMetadataDto]
     */
    @Suppress("TOO_LONG_FUNCTION")
    @Transactional
    fun save(
        vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ): Mono<VulnerabilityMetadataDto> = blockingToMono {
        vulnerabilityDto.identifier.ifEmpty {
            vulnerabilityGeneratedIdRepository.saveAndFlush(VulnerabilityGeneratedId()).getIdentifier()
        }
    }
        .flatMap { identifier ->
            cosvService.generateAndSave(
                vulnerabilityDto.copy(
                    identifier = identifier,
                    userInfo = UserInfo(authentication.name),
                )
            )
        }
        .blockingMap { metadataDto ->
            val metadata = vulnerabilityMetadataRepository.findByIdentifier(metadataDto.identifier).orNotFound()

            val existedTags = tagRepository.findByNameIn(vulnerabilityDto.tags)
            val existedTagNames = existedTags.map { tag -> tag.name }
            val notFoundTagNames = vulnerabilityDto.tags.filter { it !in existedTagNames }
            val newTags = tagRepository.saveAll(notFoundTagNames.map { Tag(it) })

            vulnerabilityMetadataProjectRepository.saveAll(
                vulnerabilityDto.projects.map { dto -> dto.toEntity(metadata) }
            )

            lnkVulnerabilityMetadataUserRepository.saveAll(
                vulnerabilityDto.participants.map { userDto ->

                    val participant = userRepository.findByName(userDto.name)
                        .orNotFound { "Not found user by name ${userDto.name}" }

                    LnkVulnerabilityMetadataUser(
                        vulnerabilityMetadataId = metadata.requiredId(),
                        user = participant,
                    )
                }
            )

            val tagLinks = existedTags.plus(newTags).map { LnkVulnerabilityMetadataTag(metadata, it) }
            lnkVulnerabilityMetadataTagRepository.saveAll(tagLinks)

            metadataDto
        }

    /**
     * @param vulnerabilityDto
     * @param authentication
     * @throws ResponseStatusException
     */
    fun update(vulnerabilityDto: VulnerabilityDto, authentication: Authentication): Mono<VulnerabilityMetadataDto> = blockingToMono {
        val userId = authentication.userId()

        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()

        // only Super Users and owners of unapproved vuln. can edit it
        if (authentication.hasRole(Role.SUPER_ADMIN) || (userId == metadata.user.requiredId() && metadata.status != VulnerabilityStatus.APPROVED)) {
            val metadataUpdate = metadata.apply {
                status = vulnerabilityDto.status
            }
            vulnerabilityMetadataRepository.save(metadataUpdate)
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }.flatMap {
        cosvService.update(vulnerabilityDto.identifier) { cosv ->
            cosv.copy(
                summary = vulnerabilityDto.shortDescription,
                details = vulnerabilityDto.description.orEmpty(),
                severity = cosv.severity?.takeUnless { it.isEmpty() }
                    ?.let { severity ->
                        severity.first().let { entry ->
                            severity.minus(entry).plus(entry.copy(scoreNum = vulnerabilityDto.progress.toString()))
                        }
                    } ?: listOf(
                    vulnerabilityDto.progress.asSeverity()
                )
            ).toMono()
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityIdentifier: String) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.APPROVED
        }
        vulnerabilityMetadataRepository.save(metadataUpdate)

        val user = metadata.user
        user.apply {
            rating += VULNERABILITY_OWNER_RATING
        }
        userRepository.save(user)

        metadata.organization?.let { organization ->
            organization.apply { rating += VULNERABILITY_ORGANIZATION_RATING }
            organizationRepository.save(organization)
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityIdentifier: String) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.REJECTED
        }
        vulnerabilityMetadataRepository.save(metadataUpdate)
    }

    /**
     * @param name name of vulnerability
     */
    @Transactional
    fun delete(name: String) {
        vulnerabilityMetadataRepository.deleteByIdentifier(name)
    }

    /**
     * @param name name of vulnerability
     * @return [Flux] with deleted versions ([VulnerabilityMetadata.modified])
     */
    fun deleteAllVersions(name: String): Flux<LocalDateTime> = cosvRepository.deleteAll(name)

    /**
     * @param vulnerabilityIdentifier
     * @param authentication
     * @throws ResponseStatusException
     */
    @Transactional
    fun sendToReview(
        vulnerabilityIdentifier: String,
        authentication: Authentication,
    ) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()

        if ((authentication.hasRole(Role.SUPER_ADMIN) || authentication.userId() == metadata.user.requiredId()) && metadata.status == VulnerabilityStatus.REJECTED) {
            val metadataUpdate = metadata.apply {
                status = VulnerabilityStatus.PENDING_REVIEW
            }
            vulnerabilityMetadataRepository.save(metadataUpdate)
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return [VulnerabilityDto] with saved [vulnerabilityProjectDtos]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityProjectDtos.first().vulnerabilityIdentifier)?.let { metadata ->
        vulnerabilityMetadataProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityMetadataProject(
                    name = dto.name,
                    url = dto.url,
                    versions = dto.versions,
                    type = dto.type,
                    vulnerabilityMetadata = metadata,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @return [Mono] with updated identifier
     */
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
    ): Mono<String> = when (vulnerabilityDateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED -> Mono.error(
            ResponseStatusException(
                HttpStatus.FORBIDDEN,
                "System dates cannot be updated"
            )
        )

        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = vulnerabilityDateDto.date).toMono()
            }

        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = vulnerabilityDateDto.date).toMono()
            }

        else ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = vulnerabilityDateDto.asTimelineEntry()
                        .let { timelineEntry ->
                            cosv.timeline?.plus(timelineEntry) ?: listOf(timelineEntry)
                        }
                ).toMono()
            }
    }.map { it.identifier }

    /**
     * @param identifier vulnerability identifier
     * @param userName - name of user in vulnerability
     * @return [Mono] with updated identifier
     */
    fun saveUser(
        userName: String,
        identifier: String,
    ): Mono<String> = blockingToMono {
        val user = userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
        vulnerabilityMetadataRepository.findByIdentifier(identifier)?.let { metadata ->
            lnkVulnerabilityMetadataUserRepository.save(
                LnkVulnerabilityMetadataUser(
                    vulnerabilityMetadataId = metadata.requiredId(),
                    user = user,
                )
            )
        }
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = user.toUserInfo()
                            .asCredit()
                            .let { credit ->
                                cosv.credits?.plus(credit) ?: listOf(credit)
                            }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param userName name of user
     * @param identifier vulnerability identifier
     * @return [Mono] with updated identifier
     */
    fun deleteUser(userName: String, identifier: String): Mono<String> = blockingToMono {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        lnkVulnerabilityMetadataUserRepository.deleteByUserNameAndVulnerabilityMetadataId(userName, metadata.requiredId())
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = cosv.credits
                            ?.minus(user.toUserInfo().asCredit())
                            ?.takeUnless { it.isEmpty() }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param identifier vulnerability identifier
     * @return list users
     */
    fun getUsers(identifier: String) = vulnerabilityMetadataRepository.findByIdentifier(identifier)
        .orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId())
                .map { it.user.toUserInfo() }
        }

    /**
     * @param name name of project
     * @param identifier vulnerability identifier
     * @return [Unit]
     */
    @Transactional
    fun deleteProject(
        name: String,
        identifier: String,
    ) = vulnerabilityMetadataProjectRepository.deleteByNameAndVulnerabilityMetadataIdentifier(name, identifier)

    /**
     * @param dateDto [VulnerabilityDateDto] that should be deleted
     * @return [Mono] with vulnerability identifier
     */
    fun deleteDate(dateDto: VulnerabilityDateDto): Mono<String> = when (dateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED -> Mono.error(ResponseStatusException(HttpStatus.FORBIDDEN, "System dates cannot be deleted"))
        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = null).toMono()
            }
        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = null).toMono()
            }
        else ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = cosv.timeline?.minus(dateDto.asTimelineEntry())?.takeUnless { it.isEmpty() },
                ).toMono()
            }
    }.map { it.identifier }

    private fun getPredicateForTags(
        root: Root<VulnerabilityMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        tags: Set<String>
    ): Predicate = if (tags.isEmpty()) {
        cb.and()
    } else {
        val subquery = cq.subquery(Long::class.java)
        val lnkVulnerabilityMetadataTagRoot = subquery.from(LnkVulnerabilityMetadataTag::class.java)
        val tagJoin: Join<LnkVulnerabilityMetadataTag, Tag> = lnkVulnerabilityMetadataTagRoot.join("tag", JoinType.LEFT)

        val cosvMetadataIdPath: Path<Long> = lnkVulnerabilityMetadataTagRoot.get<VulnerabilityMetadata>("vulnerabilityMetadata").get("id")

        subquery.select(cosvMetadataIdPath)
            .where(
                cb.and(
                    tagJoin.get<String>("name").`in`(tags),
                    cb.equal(
                        root.get<Long>("id"),
                        cosvMetadataIdPath,
                    )
                )
            )

        cb.exists(subquery)
    }

    companion object {
        private const val VULNERABILITY_ORGANIZATION_RATING = 10
        private const val VULNERABILITY_OWNER_RATING = 10

        private fun VulnerabilityProjectDto.toEntity(
            metadata: VulnerabilityMetadata,
        ) = VulnerabilityMetadataProject(
            name = name,
            url = url,
            versions = versions,
            type = type,
            vulnerabilityMetadata = metadata,
        )
    }
}
