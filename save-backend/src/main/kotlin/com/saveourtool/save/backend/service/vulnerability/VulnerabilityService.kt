package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.OrganizationRepository
import com.saveourtool.save.backend.repository.TagRepository
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.repository.vulnerability.*
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.cosv.repository.CosvMetadataRepository
import com.saveourtool.save.cosv.repository.CosvRepository
import com.saveourtool.save.cosv.repository.LnkCosvMetadataTagRepository
import com.saveourtool.save.cosv.service.CosvService
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.Tag
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.CosvMetadata
import com.saveourtool.save.entities.cosv.LnkCosvMetadataTag
import com.saveourtool.save.entities.vulnerabilities.*
import com.saveourtool.save.entities.vulnerability.*
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.*

import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

import javax.persistence.criteria.*

import kotlinx.datetime.LocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
@Suppress("LongParameterList")
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val cosvMetadataProjectRepository: VulnerabilityProjectRepository,
    private val vulnerabilityDateRepository: VulnerabilityDateRepository,
    private val lnkVulnerabilityUserRepository: LnkVulnerabilityUserRepository,
    private val userRepository: UserRepository,
    private val organizationRepository: OrganizationRepository,
    private val lnkVulnerabilityTagRepository: LnkVulnerabilityTagRepository,
    private val cosvService: CosvService,
    private val cosvRepository: CosvRepository,
    private val cosvMetadataRepository: CosvMetadataRepository,
    private val lnkCosvMetadataTagRepository: LnkCosvMetadataTagRepository,
    private val tagRepository: TagRepository,
) {
    private fun List<CosvMetadata>.toTagMap(): Map<CosvMetadata, Set<Tag>> = lnkCosvMetadataTagRepository.findAllById(this.map { it.requiredId() })
        .map { link -> link.cosvMetadata to link.tag }
        .groupBy { (metadata, _) -> metadata }
        .mapValues { (_, list) -> list.map { it.second }.toSet() }

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = cosvMetadataRepository.findByCosvId(name)?.toDto()?.toVulnerabilityDto()

    /**
     * @param userName creator of vulnerability
     * @return list of vulnerabilities
     */
    fun findByUserNameAndStatus(userName: String): List<VulnerabilityDto> {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityRepository.findByUserId(user.requiredId()).map { it.toDto() }
    }

    /**
     * @param userName
     * @param status
     * @return count of vulnerabilities
     */
    fun countByUserNameAndStatus(userName: String, status: VulnerabilityStatus): Int {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityRepository.countByUserIdAndStatus(user.requiredId(), status)
    }

    /**
     * @param organizationName name of organization
     * @param status status of vulnerability
     * @return list of vulnerabilities
     */
    fun findByOrganizationNameAndStatus(organizationName: String, status: VulnerabilityStatus): List<VulnerabilityDto> =
            vulnerabilityRepository.findByOrganizationNameAndStatus(organizationName, status).map { it.toDto() }

    /**
     * @param filter filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @return list of vulnerabilities with that match [filter]
     */
    @Suppress(
        "TOO_LONG_FUNCTION",
        "LongMethod",
        "CyclomaticComplexMethod",
    )
    fun getFilteredWithUserInfos(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): List<VulnerabilityDto> {
        val metadataList = cosvMetadataRepository.findAll { root, cq, cb ->
            with(filter) {
                val namePredicate = if (identifierPrefix.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("cosvId"), "%$identifierPrefix%")
                }

                val ownerPredicate = authentication?.let {
                    val userId = authentication.userId()

                    if (isOwner) {
                        cb.equal(root.get<Vulnerability>("userId"), userId)
                    } else {
                        cb.and()
                    }
                } ?: cb.and()

                val statusPredicate = status?.let { status ->
                    cb.equal(root.get<VulnerabilityStatus>("status"), status)
                } ?: cb.and()

                val languagePredicate = language?.let { language ->
                    cb.equal(root.get<VulnerabilityLanguage>("language"), language)
                } ?: cb.and()

                val organizationPredicate = organizationName?.let { organization ->
                    cb.equal(root.get<Organization>("organization").get<String>("name"), organization)
                } ?: cb.and()

                val authorPredicate = authorName?.let { author ->
                    val subquery: Subquery<Long> = cq.subquery(Long::class.java)
                    val userRoot = subquery.from(User::class.java)

                    subquery.select(userRoot.get("id")).where(cb.equal(userRoot.get<String>("name"), author))

                    cb.`in`(root.get<Long>("userId")).value(subquery)
                } ?: cb.and()

                cb.and(
                    namePredicate,
                    ownerPredicate,
                    statusPredicate,
                    languagePredicate,
                    authorPredicate,
                    organizationPredicate,
                    getPredicateForTags(root, cq, cb, tags),
                )
            }
        }
            .distinctBy { it.requiredId() }

        val userIds = metadataList.map { it.user.requiredId() }
        val userInfos = userRepository.findAllById(userIds)
        val tagMap = metadataList.toTagMap()
        return metadataList.map { metadata -> metadata to tagMap[metadata].orEmpty() }
            .map { (metadata, tags) ->
                val correspondingUserInfo =
                        userInfos.find { user -> user.id == metadata.user.requiredId() }?.toUserInfo()
                metadata.toDto().toVulnerabilityDto().copy(
                    userInfo = correspondingUserInfo ?: UserInfo(name = "?"),
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByIdentifier(name: String): Mono<VulnerabilityDto> =
            cosvRepository.findLatestRawExt(name)
                .blockingMap { rawCosvExt ->
                    rawCosvExt to lnkCosvMetadataTagRepository.findAllByCosvMetadataCosvId(rawCosvExt.identifier)
                }
                .map { (rawCostExt, tags) ->
                    rawCostExt.toVulnerabilityDtoWithDescription()
                        .copy(
                            dates = rawCostExt.dates,
                            participants = rawCostExt.participants,
                            userInfo = rawCostExt.userInfo,
                            tags = tags.map { it.tag.name }.toSet(),
                        )
                }

    /**
     * @param vulnerabilityDto
     * @param authentication
     * @throws ResponseStatusException
     */
    @Transactional
    fun update(vulnerabilityDto: VulnerabilityDto, authentication: Authentication) {
        val userId = authentication.userId()

        val vulnerability = vulnerabilityRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()

        if (!authentication.hasRole(Role.SUPER_ADMIN) && (userId != vulnerability.userId || vulnerability.status == VulnerabilityStatus.APPROVED)) {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }

        val vulnerabilityUpdate = vulnerability.apply {
            progress = vulnerabilityDto.progress
            description = vulnerabilityDto.description.orEmpty()
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityIdentifier: String) {
        val metadata = cosvMetadataRepository.findByCosvId(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.APPROVED
        }
        cosvMetadataRepository.save(metadataUpdate)

        val user = metadata.user
        user.apply {
            rating += VULNERABILITY_OWNER_RATING
        }
        userRepository.save(user)

        metadata.organization?.let { organization ->
            organization.apply { rating += VULNERABILITY_ORGANIZATION_RATING }
            organizationRepository.save(organization)
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityIdentifier: String) {
        val metadata = cosvMetadataRepository.findByCosvId(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.REJECTED
        }
        cosvMetadataRepository.save(metadataUpdate)
    }

    /**
     * @param name name of vulnerability
     * @throws ResponseStatusException
     */
    fun delete(name: String): Flux<LocalDateTime> = cosvRepository.delete(name)

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return [VulnerabilityDto] with saved [vulnerabilityProjectDtos]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = cosvMetadataRepository.findByCosvId(vulnerabilityProjectDtos.first().vulnerabilityIdentifier)?.let { metadata ->
        cosvMetadataProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityProject(
                    name = dto.name,
                    url = dto.url,
                    versions = dto.versions,
                    type = dto.type,
                    vulnerability = metadata,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @param authentication - auth info of a current user
     * @return [Mono] with updated identifier
     */
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ): Mono<String> = cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
        cosv.copy(
            timeLine = vulnerabilityDateDto.asTimelineEntry()
                .let { timelineEntry ->
                    cosv.timeLine?.plus(timelineEntry) ?: listOf(timelineEntry)
                }
        ).toMono()
    }.map { it.cosvId }

    /**
     * @param identifier vulnerability identifier
     * @param userName - name of user in vulnerability
     * @return [Mono] with updated identifier
     */
    fun saveUser(
        userName: String,
        identifier: String,
    ): Mono<String> = cosvService.update(identifier) { cosv ->
        blockingToMono {
            userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
        }
            .map { user ->
                cosv.copy(
                    credits = user.toUserInfo()
                        .asCredit()
                        .let { credit ->
                            cosv.credits?.plus(credit) ?: listOf(credit)
                        }
                )
            }
    }.map { it.cosvId }

    /**
     * @param userName name of user
     * @param identifier vulnerability identifier
     * @return [Mono] with updated identifier
     */
    fun deleteUser(userName: String, identifier: String): Mono<String> = cosvService.update(identifier) { cosv ->
        blockingToMono {
            userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
        }
            .map { user ->
                cosv.copy(
                    credits = cosv.credits
                        ?.minus(user.toUserInfo().asCredit())
                        ?.takeUnless { it.isEmpty() }
                )
            }
    }.map { it.cosvId }

    /**
     * @param identifier vulnerability identifier
     * @return list users
     */
    fun getUsers(identifier: String) = cosvRepository.findLatestRawExt(identifier)
        .map { it.participants }
        .block()
        .orEmpty()

    /**
     * @param name name of project
     * @param identifier vulnerability identifier
     * @return updated [Vulnerability]
     */
    @Transactional
    fun deleteProject(
        name: String,
        identifier: String,
    ) = cosvMetadataProjectRepository.deleteByNameAndVulnerabilityIdentifier(name, identifier)

    /**
     * @param dateDto [VulnerabilityDateDto] that corresponds with [VulnerabilityDate] that should be deleted
     * @return [Unit]
     */
    @Transactional
    fun deleteDate(dateDto: VulnerabilityDateDto) = cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
        cosv.copy(
            timeLine = cosv.timeLine?.minus(dateDto.asTimelineEntry())?.takeUnless { it.isEmpty() }
        ).toMono()
    }.map { it.cosvId }

    private fun getPredicateForTags(
        root: Root<CosvMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        tags: Set<String>
    ): Predicate = if (tags.isEmpty()) {
        cb.and()
    } else {
        val subquery = cq.subquery(Long::class.java)
        val lnkCosvMetadataTagRoot = subquery.from(LnkCosvMetadataTag::class.java)
        val tagJoin: Join<LnkVulnerabilityTag, Tag> = lnkCosvMetadataTagRoot.join("tag", JoinType.LEFT)

        val cosvMetadataIdPath: Path<Long> = lnkCosvMetadataTagRoot.get<Vulnerability>("cosvMetadata").get("id")

        subquery.select(cosvMetadataIdPath)
            .where(
                cb.and(
                    tagJoin.get<String>("name").`in`(tags),
                    cb.equal(
                        root.get<Long>("id"),
                        cosvMetadataIdPath,
                    )
                )
            )

        cb.exists(subquery)
    }

    companion object {
        private const val VULNERABILITY_ORGANIZATION_RATING = 10
        private const val VULNERABILITY_OWNER_RATING = 10

        private fun VulnerabilityProjectDto.toEntity(
            vulnerability: Vulnerability,
        ) = VulnerabilityProject(
            name = name,
            url = url,
            versions = versions,
            type = type,
            vulnerability = vulnerability,
        )
    }
}
