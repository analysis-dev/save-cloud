package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.AuthenticationDetails
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityDescriptionRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityProjectRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityRepository
import com.saveourtool.save.entities.vulnerabilities.Vulnerability
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityDescription
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityProject
import com.saveourtool.save.entities.vulnerability.VulnerabilityDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityProjectDto
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.utils.getByIdOrNotFound
import com.saveourtool.save.utils.orNotFound
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import java.time.LocalDateTime
import kotlin.random.Random

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityDescriptionRepository: VulnerabilityDescriptionRepository,
    private val vulnerabilityProjectRepository: VulnerabilityProjectRepository,
    private val userRepository: UserRepository,
) {
    /**
     * @param name name of vulnerability
     * @param isActive admin vulnerability check flag
     * @return vulnerability by name
     */
    fun findByNameAndIsActive(name: String, isActive: Boolean) = vulnerabilityRepository.findByNameAndIsActive(name, isActive)

    /**
     * @return all vulnerabilities
     */
    fun findAll(): List<Vulnerability> = vulnerabilityRepository.findAll()

    /**
     * @param filters filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @return list of vulnerabilities with that match [filters]
     */
    fun getFiltered(
        filters: VulnerabilityFilter,
        authentication: Authentication?,
    ): List<Vulnerability> =
            vulnerabilityRepository.findAll { root, _, cb ->
                with(filters) {
                    val namePredicate = if (prefixName.isBlank()) {
                        cb.and()
                    } else {
                        cb.like(root.get("name"), "%$prefixName%")
                    }

                    val ownerPredicate = authentication?.let {
                        val userId = (authentication.details as AuthenticationDetails).id
                        if (isOwner) {
                            cb.equal(root.get<Vulnerability>("userId"), userId)
                        } else {
                            cb.and()
                        }
                    } ?: cb.and()

                    cb.and(
                        namePredicate,
                        cb.equal(root.get<Vulnerability>("isActive"), active),
                        ownerPredicate,
                    )
                }
            }

    /**
     * @param filters filters for vulnerability
     * @return list of vulnerabilities with that match [filters]
     */
    @Suppress("WRONG_OVERLOADING_FUNCTION_ARGUMENTS")
    fun getFiltered(
        filters: VulnerabilityFilter,
    ): List<Vulnerability> =
            vulnerabilityRepository.findAll { root, _, cb ->
                with(filters) {
                    val namePredicate = if (prefixName.isBlank()) {
                        cb.and()
                    } else {
                        cb.like(root.get("name"), "%$prefixName%")
                    }

                    cb.and(
                        namePredicate,
                        cb.equal(root.get<Vulnerability>("isActive"), active),
                    )
                }
            }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByName(name: String): VulnerabilityDto {
        val description = vulnerabilityDescriptionRepository.findByVulnerabilityName(name)?.description.orEmpty()
        return vulnerabilityRepository.findByName(name)?.toDtoWithDescription(description) ?: VulnerabilityDto.empty
    }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     */
    @Transactional
    fun save(
        vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ) {
        val userId = (authentication.details as AuthenticationDetails).id
        val user = userRepository.getByIdOrNotFound(userId)
        val vulnerability = Vulnerability(
            name = "default-${Random.nextInt()}",
            progress = vulnerabilityDto.progress,
            projects = emptyList(),
            isActive = false,
            userId = user.requiredId(),
        )
        val vulnerabilityNew = vulnerabilityRepository.saveAndFlush(vulnerability)
        val newName = "SOTV-${LocalDateTime.now().year}-${vulnerabilityNew.id}"

        val vulnerabilityWithName = vulnerabilityRepository.save(
            vulnerabilityNew.apply {
                name = newName
                projects = vulnerabilityDto.projects.map { dto ->
                    VulnerabilityProject(
                        name = dto.name,
                        url = dto.url,
                        versions = dto.versions,
                        isOpenSource = dto.isOpenSource,
                        vulnerability = vulnerabilityNew,
                    )
                }
            }
        )

        val description = VulnerabilityDescription(
            vulnerability = vulnerabilityWithName,
            description = vulnerabilityDto.description.orEmpty(),
        )
        vulnerabilityDescriptionRepository.save(description)
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun update(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByName(vulnerabilityDto.name).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            progress = vulnerabilityDto.progress
            isActive = vulnerabilityDto.isActive
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param name name of vulnerability
     * @throws ResponseStatusException
     */
    @Transactional
    fun delete(name: String) {
        val vulnerability = vulnerabilityRepository.findByName(name).orNotFound()
        vulnerabilityRepository.delete(vulnerability)
    }

    /**
     * @param vulnerabilityDtos dto list of vulnerability projects
     */
    @Transactional
    fun saveAllProjects(vulnerabilityDtos: List<VulnerabilityProjectDto>) {
        vulnerabilityRepository.findByName(vulnerabilityDtos.first().vulnerabilityName)?.let { vulnerability ->
            vulnerabilityProjectRepository.saveAll(
                vulnerabilityDtos.map { dto ->
                    VulnerabilityProject(
                        name = dto.name,
                        url = dto.url,
                        versions = dto.versions,
                        isOpenSource = dto.isOpenSource,
                        vulnerability = vulnerability,
                    )
                }
            )
        }
    }

    /**
     * @param name name of project
     * @param vulnerabilityName name of vulnerability
     * @return Unit
     */
    @Transactional
    fun deleteProject(name: String, vulnerabilityName: String) = vulnerabilityProjectRepository.deleteByNameAndVulnerabilityName(name, vulnerabilityName)
}
