package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.OrganizationRepository
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.repository.vulnerability.LnkVulnerabilityUserRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityDateRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityProjectRepository
import com.saveourtool.save.backend.repository.vulnerability.VulnerabilityRepository
import com.saveourtool.save.entities.vulnerabilities.LnkVulnerabilityUser
import com.saveourtool.save.entities.vulnerabilities.Vulnerability
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityDate
import com.saveourtool.save.entities.vulnerabilities.VulnerabilityProject
import com.saveourtool.save.entities.vulnerability.VulnerabilityDateDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityProjectDto
import com.saveourtool.save.entities.vulnerability.VulnerabilityStatus
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.getByIdOrNotFound
import com.saveourtool.save.utils.orNotFound

import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException

import java.time.LocalDateTime

import kotlin.random.Random
import kotlinx.datetime.toJavaLocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityProjectRepository: VulnerabilityProjectRepository,
    private val vulnerabilityDateRepository: VulnerabilityDateRepository,
    private val lnkVulnerabilityUserRepository: LnkVulnerabilityUserRepository,
    private val userRepository: UserRepository,
    private val organizationRepository: OrganizationRepository,
) {
    /**
     * @param vulnerabilityIdentifier identifier of vulnerability
     * @param status status of vulnerability
     * @return vulnerability by name
     */
    fun findByVulnerabilityIdentifierAndStatus(vulnerabilityIdentifier: String, status: VulnerabilityStatus) = vulnerabilityRepository.findByVulnerabilityIdentifierAndStatus(
        vulnerabilityIdentifier,
        status
    )

    /**
     * @param name name of vulnerability
     * @param status status of vulnerability
     * @return vulnerability by name
     */
    fun findByNameAndStatus(name: String, status: VulnerabilityStatus) = vulnerabilityRepository.findByNameAndStatus(name, status)

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = vulnerabilityRepository.findByName(name)

    /**
     * @param userName creator of vulnerability
     * @return list of vulnerabilities
     */
    fun findByUserNameAndStatus(userName: String): List<VulnerabilityDto> {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityRepository.findByUserId(user.requiredId()).map { it.toDto() }
    }

    /**
     * @param organizationName name of organization
     * @param status status of vulnerability
     * @return list of vulnerabilities
     */
    fun findByOrganizationNameAndStatus(organizationName: String, status: VulnerabilityStatus): List<Vulnerability> =
            vulnerabilityRepository.findByOrganizationNameAndStatus(organizationName, status)

    /**
     * @param vulnerabilityId id of vulnerability
     * @return list of vulnerabilities
     */
    fun findUsersByVulnerabilityId(
        vulnerabilityId: Long
    ): List<LnkVulnerabilityUser> = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerabilityId)

    /**
     * @return all vulnerabilities
     */
    fun findAll(): List<Vulnerability> = vulnerabilityRepository.findAll()

    /**
     * @param filters filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @return list of vulnerabilities with that match [filters]
     */
    fun getFilteredWithUserInfos(
        filters: VulnerabilityFilter,
        authentication: Authentication?,
    ): List<VulnerabilityDto> {
        val vulnerabilities = vulnerabilityRepository.findAll { root, _, cb ->
            with(filters) {
                val namePredicate = if (prefixName.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("name"), "%$prefixName%")
                }

                val ownerPredicate = authentication?.let {
                    val userId = authentication.userId()
                    if (isOwner) {
                        cb.equal(root.get<Vulnerability>("userId"), userId)
                    } else {
                        cb.and()
                    }
                } ?: cb.and()

                cb.and(
                    namePredicate,
                    cb.equal(root.get<Vulnerability>("status"), status),
                    ownerPredicate,
                )
            }
        }
        val userIds = vulnerabilities.map { it.userId }
        val userInfos = userRepository.findAllById(userIds)
        return vulnerabilities.map { vulnerability ->
            val correspondingUserInfo = userInfos.find { user -> user.id == vulnerability.userId }?.toUserInfo()
            vulnerability.toDto().copy(userInfo = correspondingUserInfo ?: UserInfo(name = "?", source = "?"))
        }
    }

    /**
     * @param filters
     * @return list of vulnerabilities with that match [filters]
     */
    @Suppress("WRONG_OVERLOADING_FUNCTION_ARGUMENTS")
    fun getFilteredWithUserInfos(
        filters: VulnerabilityFilter,
    ): List<VulnerabilityDto> {
        val vulnerabilities = vulnerabilityRepository.findAll { root, _, cb ->
            with(filters) {
                val namePredicate = if (prefixName.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("name"), "%$prefixName%")
                }

                cb.and(
                    namePredicate,
                    cb.equal(root.get<Vulnerability>("status"), status),
                )
            }
        }
        val userIds = vulnerabilities.map { it.userId }
        val userInfos = userRepository.findAllById(userIds)
        return vulnerabilities.map { vulnerability ->
            val correspondingUserInfo = userInfos.find { user -> user.id == vulnerability.userId }?.toUserInfo()
            vulnerability.toDto().copy(userInfo = correspondingUserInfo ?: UserInfo(name = "?", source = "?"))
        }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    @Transactional
    fun getVulnerabilityWithDescriptionByName(name: String): VulnerabilityDto? {
        val vulnerability = vulnerabilityRepository.findByName(name).orNotFound {
            "Not found vulnerability by name $name"
        }
        val dates = vulnerabilityDateRepository.findByVulnerabilityName(name).map { it.toDto() }
        val users = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerability.requiredId()).map { it.user.toUserInfo() }
        val authorUserInfo = userRepository.getByIdOrNotFound(vulnerability.userId).toUserInfo()

        return vulnerability.toDtoWithDescription().copy(
            dates = dates,
            participants = users,
            userInfo = authorUserInfo,
        )
    }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     */
    @Transactional
    fun save(
        vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ) {
        val userId = authentication.userId()
        val user = userRepository.getByIdOrNotFound(userId)
        val organizationNew = vulnerabilityDto.organization?.name?.let { organizationRepository.findByName(it) }
        val vulnerability = Vulnerability(
            name = "default-${Random.nextInt()}",
            vulnerabilityIdentifier = vulnerabilityDto.vulnerabilityIdentifier,
            description = vulnerabilityDto.description.orEmpty(),
            shortDescription = vulnerabilityDto.shortDescription,
            relatedLink = vulnerabilityDto.relatedLink,
            language = vulnerabilityDto.language,
            progress = vulnerabilityDto.progress,
            projects = emptyList(),
            status = VulnerabilityStatus.CREATED,
            userId = user.requiredId(),
            organization = organizationNew,
        )
        val vulnerabilityNew = vulnerabilityRepository.saveAndFlush(vulnerability)
        val newName = "SOTV-${LocalDateTime.now().year}-${vulnerabilityNew.id}"

        vulnerabilityRepository.save(
            vulnerabilityNew.apply {
                name = newName
                projects = vulnerabilityDto.projects.map { dto ->
                    VulnerabilityProject(
                        name = dto.name,
                        url = dto.url,
                        versions = dto.versions,
                        type = dto.type,
                        vulnerability = vulnerabilityNew,
                    )
                }
            }
        )

        vulnerabilityDateRepository.saveAll(
            vulnerabilityDto.dates.map { dto ->
                VulnerabilityDate(
                    date = dto.date.toJavaLocalDateTime(),
                    type = dto.type,
                    vulnerability = vulnerabilityNew,
                    userId = user.requiredId(),
                )
            }
        )

        lnkVulnerabilityUserRepository.saveAll(
            vulnerabilityDto.participants.map { userDto ->

                val participant = userRepository.findByName(userDto.name).orNotFound { "Not found user by name ${userDto.name}" }

                LnkVulnerabilityUser(
                    vulnerabilityId = vulnerabilityNew.requiredId(),
                    user = participant,
                )
            }
        )
    }

    /**
     * @param vulnerabilityDtos dtos of new vulnerabilities
     * @param authentication auth info of a current user
     */
    fun saveAll(
        vulnerabilityDtos: List<VulnerabilityDto>,
        authentication: Authentication,
    ) {
        vulnerabilityDtos.map { dto -> save(dto, authentication) }
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun update(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByName(vulnerabilityDto.name).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            progress = vulnerabilityDto.progress
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByName(vulnerabilityDto.name).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)

        val user = userRepository.getByIdOrNotFound(vulnerability.userId)
        user.apply {
            rating += VULNERABILITY_OWNER_RATING
        }
        userRepository.save(user)

        vulnerabilityDto.organization?.name?.let { organizationName ->
            val organizationNew = organizationRepository.findByName(organizationName).orNotFound { "Not found organization by name = $organizationName" }
            organizationNew.apply { rating += VULNERABILITY_ORGANIZATION_RATING }
            organizationRepository.save(organizationNew)
        }
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByName(vulnerabilityDto.name).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param name name of vulnerability
     * @throws ResponseStatusException
     */
    @Transactional
    fun delete(name: String) {
        val vulnerability = vulnerabilityRepository.findByName(name).orNotFound()
        vulnerabilityRepository.delete(vulnerability)
    }

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return [VulnerabilityDto] with saved [vulnerabilityProjectDtos]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = vulnerabilityRepository.findByName(vulnerabilityProjectDtos.first().vulnerabilityName)?.let { vulnerability ->
        vulnerabilityProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityProject(
                    name = dto.name,
                    url = dto.url,
                    versions = dto.versions,
                    type = dto.type,
                    vulnerability = vulnerability,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @param authentication - auth info of a current user
     */
    @Transactional
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ) {
        val userId = authentication.userId()
        val user = userRepository.getByIdOrNotFound(userId)

        vulnerabilityRepository.findByName(vulnerabilityDateDto.vulnerabilityName)?.let { vulnerability ->
            vulnerabilityDateRepository.save(
                vulnerabilityDateDto.let { dto ->
                    VulnerabilityDate(
                        date = dto.date.toJavaLocalDateTime(),
                        type = dto.type,
                        vulnerability = vulnerability,
                        userId = user.requiredId(),
                    )
                }
            )
        }
    }

    /**
     * @param vulnerabilityName name of vulnerability
     * @param userName - name of user in vulnerability
     */
    @Transactional
    fun saveUser(
        userName: String,
        vulnerabilityName: String,
    ) {
        val user = userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }

        vulnerabilityRepository.findByName(vulnerabilityName)?.let { vulnerability ->
            lnkVulnerabilityUserRepository.save(
                LnkVulnerabilityUser(
                    vulnerabilityId = vulnerability.requiredId(),
                    user = user,
                )
            )
        }
    }

    /**
     * @param userName name of user
     * @param vulnerabilityName name of vulnerability
     */
    @Transactional
    fun deleteUser(userName: String, vulnerabilityName: String) {
        val vulnerability = vulnerabilityRepository.findByName(vulnerabilityName).orNotFound { "Not found user by vulnerability $vulnerabilityName" }
        lnkVulnerabilityUserRepository.deleteByUserNameAndVulnerabilityId(userName, vulnerability.requiredId())
    }

    /**
     * @param vulnerabilityId
     * @return list users
     */
    fun getUsers(vulnerabilityId: Long) = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerabilityId)

    /**
     * @param name name of project
     * @param vulnerabilityName name of vulnerability
     * @return updated [Vulnerability]
     */
    @Transactional
    fun deleteProject(name: String, vulnerabilityName: String) = vulnerabilityProjectRepository.deleteByNameAndVulnerabilityName(name, vulnerabilityName)

    /**
     * @param dateDto [VulnerabilityDateDto] that corresponds with [VulnerabilityDate] that should be deleted
     * @return [Unit]
     */
    @Transactional
    fun deleteDate(dateDto: VulnerabilityDateDto) = vulnerabilityDateRepository.findByVulnerabilityNameAndType(
        dateDto.vulnerabilityName,
        dateDto.type
    )
        .orNotFound { "Could not find date for ${dateDto.vulnerabilityName} of type ${dateDto.type} (${dateDto.date})." }
        .let { vulnerabilityDateRepository.delete(it) }

    companion object {
        private const val VULNERABILITY_ORGANIZATION_RATING = 10
        private const val VULNERABILITY_OWNER_RATING = 10
    }
}
