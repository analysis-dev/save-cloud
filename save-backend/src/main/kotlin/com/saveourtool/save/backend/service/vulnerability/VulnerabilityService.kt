package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.service.TagService
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.cosv.repository.*
import com.saveourtool.save.cosv.service.CosvService
import com.saveourtool.save.cosv.service.VulnerabilityRatingService
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.Tag
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.*
import com.saveourtool.save.entities.vulnerability.*
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.*

import org.springframework.data.domain.PageRequest
import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

import javax.persistence.criteria.*

import kotlinx.datetime.LocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
@Suppress("LongParameterList")
class VulnerabilityService(
    private val vulnerabilityMetadataProjectRepository: VulnerabilityMetadataProjectRepository,
    private val lnkVulnerabilityMetadataUserRepository: LnkVulnerabilityMetadataUserRepository,
    private val userRepository: UserRepository,
    private val cosvService: CosvService,
    private val cosvRepository: CosvRepository,
    private val vulnerabilityMetadataRepository: VulnerabilityMetadataRepository,
    private val lnkVulnerabilityMetadataTagRepository: LnkVulnerabilityMetadataTagRepository,
    private val tagService: TagService,
    private val vulnerabilityRatingService: VulnerabilityRatingService,
) {
    private fun List<VulnerabilityMetadata>.toTagMap() = lnkVulnerabilityMetadataTagRepository.findByVulnerabilityMetadataIdIn(this.map { it.requiredId() })
        .map { link -> link.vulnerabilityMetadata to link.tag }
        .groupBy { (metadata, _) -> metadata }
        .mapValues { (_, list) -> list.map { it.second }.toSet() }

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = vulnerabilityMetadataRepository.findByIdentifier(name)?.toDto()

    /**
     * @param userName
     * @param status
     * @return count of vulnerabilities
     */
    fun countByUserNameAndStatus(userName: String, status: VulnerabilityStatus): Int {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityMetadataRepository.countByUserIdAndStatus(user.requiredId(), status)
    }

    /**
     * @param identifier id of vulnerability
     * @return list of vulnerabilities
     */
    fun findUsersByVulnerabilityId(
        identifier: String
    ): List<UserInfo> = vulnerabilityMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId()).map { it.user.toUserInfo() }
        }

    /**
     * @param filter filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @param page
     * @param size
     * @return list of vulnerabilities with that match [filter]
     */
    @Suppress(
        "TOO_LONG_FUNCTION",
        "LongMethod",
        "CyclomaticComplexMethod",
    )
    fun getFilteredWithUserInfos(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
        page: Int,
        size: Int,
    ): List<VulnerabilityMetadataDto> {
        val metadataList = vulnerabilityMetadataRepository.kFindAll(PageRequest.of(page, size)) { root, cq, cb ->
            getFilterPredicate(root, cq, cb, filter, authentication)
        }

        val tagMap = metadataList.content.toTagMap()
        return metadataList.content.map { metadata -> metadata to tagMap[metadata].orEmpty() }
            .map { (metadata, tags) ->
                metadata.toDto().copy(
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param filter
     * @param authentication
     * @return count of vulnerability
     */
    fun getCountVulnerabilitiesByFilter(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ) = vulnerabilityMetadataRepository.count { root, cq, cb -> getFilterPredicate(root, cq, cb, filter, authentication) }

    private fun getFilterPredicate(
        root: Root<VulnerabilityMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): Predicate {
        with(filter) {
            val namePredicate = if (identifierPrefix.isBlank()) {
                cb.and()
            } else {
                cb.like(root.get("identifier"), "%$identifierPrefix%")
            }

            val ownerPredicate = authentication?.let {
                val userId = authentication.userId()

                if (isOwner) {
                    cb.equal(root.get<User>("user").get<Long>("id"), userId)
                } else {
                    cb.and()
                }
            } ?: cb.and()

            val statusPredicate = statuses?.let { statuses ->
                cb.and(root.get<VulnerabilityStatus>("status").`in`(statuses))
            } ?: cb.and()

            val criticalityPredicate = cb.and(cb.greaterThanOrEqualTo(root.get("severityNum"), minCriticality),
                cb.lessThanOrEqualTo(root.get("severityNum"), maxCriticality))

            val languagePredicate = language?.let { language ->
                cb.equal(root.get<VulnerabilityLanguage>("language"), language)
            } ?: cb.and()

            val organizationPredicate = organizationName?.let { organization ->
                cb.equal(root.get<Organization>("organization").get<String>("name"), organization)
            } ?: cb.and()

            val authorPredicate = authorName?.let { author ->
                cb.equal(root.get<User>("user").get<String>("name"), author)
            } ?: cb.and()

            return cb.and(
                namePredicate,
                ownerPredicate,
                statusPredicate,
                criticalityPredicate,
                languagePredicate,
                authorPredicate,
                organizationPredicate,
                getPredicateForTags(root, cq, cb, tags),
            )
        }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByIdentifier(name: String): Mono<VulnerabilityExt> =
            cosvService.getVulnerabilityExt(name)

    /**
     * @param vulnerabilityExt
     * @param authentication
     * @throws ResponseStatusException
     */
    fun update(vulnerabilityExt: VulnerabilityExt, authentication: Authentication): Mono<VulnerabilityMetadataDto> = blockingToMono {
        val vulnerabilityId = vulnerabilityExt.metadataDto.identifier
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityId).orNotFound()

        // only Super Users and Owners of unapproved vuln. can edit it
        if (authentication.hasRole(Role.SUPER_ADMIN) ||
                authentication.userId() == metadata.user.requiredId() && metadata.status != VulnerabilityStatus.APPROVED) {
            // updating status in the metadata, because this field is not included into the COSV schema
            val metadataUpdate = metadata.apply {
                status = vulnerabilityExt.metadataDto.status
            }
            vulnerabilityMetadataRepository.save(metadataUpdate)

            // updating tags in the tags table and vuln->tags link table, it is also not included into COSV schema
            val existingTags = lnkVulnerabilityMetadataTagRepository
                .findAllByVulnerabilityMetadataIdentifier(vulnerabilityId)
                .map { it.tag.name }
                .toSet()

            val updatedTags = vulnerabilityExt.metadataDto.tags

            // performance issues are not possible here as tags number is very limited, but need to FixMe it
            (updatedTags - existingTags).forEach {
                tagService.addVulnerabilityTag(vulnerabilityId, it)
            }
            (existingTags - updatedTags).forEach {
                tagService.deleteVulnerabilityTag(vulnerabilityId, it)
            }
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }.flatMap {
        cosvService.update(vulnerabilityExt.metadataDto.identifier) {
            vulnerabilityExt.cosv.toMono()
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityIdentifier: String) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.APPROVED
        }
        vulnerabilityMetadataRepository.save(metadataUpdate)
        vulnerabilityRatingService.addRatingForManualUpload(metadata)
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityIdentifier: String) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.REJECTED
        }
        vulnerabilityMetadataRepository.save(metadataUpdate)
    }

    /**
     * @param name name of vulnerability
     */
    @Transactional
    fun delete(name: String) {
        vulnerabilityMetadataRepository.deleteByIdentifier(name)
    }

    /**
     * @param name name of vulnerability
     * @return [Flux] with deleted versions ([VulnerabilityMetadata.modified])
     */
    fun deleteAllVersions(name: String): Flux<LocalDateTime> = cosvRepository.deleteAll(name)

    /**
     * @param vulnerabilityIdentifier
     * @param authentication
     * @throws ResponseStatusException
     */
    @Transactional
    fun sendToReview(
        vulnerabilityIdentifier: String,
        authentication: Authentication,
    ) {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()

        if ((authentication.hasRole(Role.SUPER_ADMIN) || authentication.userId() == metadata.user.requiredId()) && metadata.status == VulnerabilityStatus.REJECTED) {
            val metadataUpdate = metadata.apply {
                status = VulnerabilityStatus.PENDING_REVIEW
            }
            vulnerabilityMetadataRepository.save(metadataUpdate)
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return list of [VulnerabilityProjectDto]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = vulnerabilityMetadataRepository.findByIdentifier(vulnerabilityProjectDtos.first().vulnerabilityIdentifier)?.let { metadata ->
        vulnerabilityMetadataProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityMetadataProject(
                    name = dto.name,
                    url = dto.repository,
                    versions = dto.versions.joinToString(PRETTY_DELIMITER),
                    type = dto.type,
                    vulnerabilityMetadata = metadata,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @return [Mono] with updated identifier
     */
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
    ): Mono<String> = when (vulnerabilityDateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED_COSV -> Mono.error(
            ResponseStatusException(
                HttpStatus.FORBIDDEN,
                "System dates cannot be updated"
            )
        )

        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = vulnerabilityDateDto.date).toMono()
            }

        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = vulnerabilityDateDto.date).toMono()
            }

        else ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = vulnerabilityDateDto.asTimelineEntry()
                        .let { timelineEntry ->
                            cosv.timeline?.plus(timelineEntry) ?: listOf(timelineEntry)
                        }
                ).toMono()
            }
    }.map { it.identifier }

    /**
     * @param identifier vulnerability identifier
     * @param userName - name of user in vulnerability
     * @return [Mono] with updated identifier
     */
    fun saveUser(
        userName: String,
        identifier: String,
    ): Mono<String> = blockingToMono {
        val user = userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
        vulnerabilityMetadataRepository.findByIdentifier(identifier)?.let { metadata ->
            lnkVulnerabilityMetadataUserRepository.save(
                LnkVulnerabilityMetadataUser(
                    vulnerabilityMetadataId = metadata.requiredId(),
                    user = user,
                )
            )
        }
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = user.toUserInfo()
                            .asCredit()
                            .let { credit ->
                                cosv.credits?.plus(credit) ?: listOf(credit)
                            }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param userName name of user
     * @param identifier vulnerability identifier
     * @return [Mono] with updated identifier
     */
    fun deleteUser(userName: String, identifier: String): Mono<String> = blockingToMono {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        lnkVulnerabilityMetadataUserRepository.deleteByUserNameAndVulnerabilityMetadataId(userName, metadata.requiredId())
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = cosv.credits
                            ?.minus(user.toUserInfo().asCredit())
                            ?.takeUnless { it.isEmpty() }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param identifier vulnerability identifier
     * @return list users
     */
    fun getUsers(identifier: String) = vulnerabilityMetadataRepository.findByIdentifier(identifier)
        .orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId())
                .map { it.user.toUserInfo() }
        }

    /**
     * @param name name of project
     * @param identifier vulnerability identifier
     * @return [Unit]
     */
    @Transactional
    fun deleteProject(
        name: String,
        identifier: String,
    ) = vulnerabilityMetadataProjectRepository.deleteByNameAndVulnerabilityMetadataIdentifier(name, identifier)

    /**
     * @param dateDto [VulnerabilityDateDto] that should be deleted
     * @return [Mono] with vulnerability identifier
     */
    fun deleteDate(dateDto: VulnerabilityDateDto): Mono<String> = when (dateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED_COSV -> Mono.error(ResponseStatusException(HttpStatus.FORBIDDEN, "System dates cannot be deleted"))
        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = null).toMono()
            }
        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = null).toMono()
            }
        else ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = cosv.timeline?.minus(dateDto.asTimelineEntry())?.takeUnless { it.isEmpty() },
                ).toMono()
            }
    }.map { it.identifier }

    private fun getPredicateForTags(
        root: Root<VulnerabilityMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        tags: Set<String>
    ): Predicate = if (tags.isEmpty()) {
        cb.and()
    } else {
        val subquery = cq.subquery(Long::class.java)
        val lnkVulnerabilityMetadataTagRoot = subquery.from(LnkVulnerabilityMetadataTag::class.java)
        val tagJoin: Join<LnkVulnerabilityMetadataTag, Tag> = lnkVulnerabilityMetadataTagRoot.join("tag", JoinType.LEFT)

        val cosvMetadataIdPath: Path<Long> = lnkVulnerabilityMetadataTagRoot.get<VulnerabilityMetadata>("vulnerabilityMetadata").get("id")

        subquery.select(cosvMetadataIdPath)
            .where(
                cb.and(
                    tagJoin.get<String>("name").`in`(tags),
                    cb.equal(
                        root.get<Long>("id"),
                        cosvMetadataIdPath,
                    )
                )
            )

        cb.exists(subquery)
    }

    companion object {
        private fun VulnerabilityProjectDto.toEntity(
            metadata: VulnerabilityMetadata,
        ) = VulnerabilityMetadataProject(
            name = name,
            url = repository,
            versions = versions.joinToString(PRETTY_DELIMITER),
            type = type,
            vulnerabilityMetadata = metadata,
        )
    }
}
