package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.OrganizationRepository
import com.saveourtool.save.backend.repository.TagRepository
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.cosv.repository.*
import com.saveourtool.save.cosv.service.CosvService
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.Tag
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.*
import com.saveourtool.save.entities.vulnerability.*
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.*

import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.kotlin.core.publisher.toMono

import javax.persistence.criteria.*

import kotlin.random.Random
import kotlinx.datetime.LocalDateTime
import kotlinx.datetime.toJavaLocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
@Suppress("LongParameterList")
class VulnerabilityService(
    private val vulnerabilityMetadataProjectRepository: VulnerabilityMetadataProjectRepository,
    private val lnkVulnerabilityMetadataUserRepository: LnkVulnerabilityMetadataUserRepository,
    private val userRepository: UserRepository,
    private val organizationRepository: OrganizationRepository,
    private val cosvService: CosvService,
    private val cosvRepository: CosvRepository,
    private val cosvMetadataRepository: VulnerabilityMetadataRepository,
    private val lnkCosvMetadataTagRepository: LnkVulnerabilityMetadataTagRepository,
    private val tagRepository: TagRepository,
) {
    private fun List<VulnerabilityMetadata>.toTagMap() = lnkCosvMetadataTagRepository.findAllById(this.map { it.requiredId() })
        .map { link -> link.vulnerabilityMetadata to link.tag }
        .groupBy { (metadata, _) -> metadata }
        .mapValues { (_, list) -> list.map { it.second }.toSet() }

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    fun findByName(name: String) = cosvMetadataRepository.findByIdentifier(name)?.toDto()?.toVulnerabilityDto()

    /**
     * @param userName creator of vulnerability
     * @return list of vulnerabilities
     */
    fun findByUserNameAndStatus(userName: String): List<VulnerabilityDto> {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return cosvMetadataRepository.findByUserId(user.requiredId()).map { it.toDto().toVulnerabilityDto() }
    }

    /**
     * @param userName
     * @param status
     * @return count of vulnerabilities
     */
    fun countByUserNameAndStatus(userName: String, status: VulnerabilityStatus): Int {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return cosvMetadataRepository.countByUserIdAndStatus(user.requiredId(), status)
    }

    /**
     * @param organizationName name of organization
     * @param status status of vulnerability
     * @return list of vulnerabilities
     */
    fun findByOrganizationNameAndStatus(organizationName: String, status: VulnerabilityStatus): List<VulnerabilityDto> =
            cosvMetadataRepository.findByOrganizationNameAndStatus(organizationName, status).map { it.toDto().toVulnerabilityDto() }

    /**
     * @param identifier id of vulnerability
     * @return list of vulnerabilities
     */
    fun findUsersByVulnerabilityId(
        identifier: String
    ): List<UserInfo> = cosvMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId()).map { it.user.toUserInfo() }
        }

    /**
     * @param filter filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @return list of vulnerabilities with that match [filter]
     */
    @Suppress(
        "TOO_LONG_FUNCTION",
        "LongMethod",
        "CyclomaticComplexMethod",
    )
    fun getFilteredWithUserInfos(
        filter: VulnerabilityFilter,
        authentication: Authentication?,
    ): List<VulnerabilityDto> {
        val metadataList = cosvMetadataRepository.findAll { root, cq, cb ->
            with(filter) {
                val namePredicate = if (identifierPrefix.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("cosvId"), "%$identifierPrefix%")
                }

                val ownerPredicate = authentication?.let {
                    val userId = authentication.userId()

                    if (isOwner) {
                        cb.equal(root.get<User>("user").get<Long>("id"), userId)
                    } else {
                        cb.and()
                    }
                } ?: cb.and()

                val statusPredicate = status?.let { status ->
                    cb.equal(root.get<VulnerabilityStatus>("status"), status)
                } ?: cb.and()

                val languagePredicate = language?.let { language ->
                    cb.equal(root.get<VulnerabilityLanguage>("language"), language)
                } ?: cb.and()

                val organizationPredicate = organizationName?.let { organization ->
                    cb.equal(root.get<Organization>("organization").get<String>("name"), organization)
                } ?: cb.and()

                val authorPredicate = authorName?.let { author ->
                    val subquery: Subquery<Long> = cq.subquery(Long::class.java)
                    val userRoot = subquery.from(User::class.java)

                    subquery.select(userRoot.get("id")).where(cb.equal(userRoot.get<String>("name"), author))

                    cb.`in`(root.get<User>("user").get<Long>("id")).value(subquery)
                } ?: cb.and()

                cb.and(
                    namePredicate,
                    ownerPredicate,
                    statusPredicate,
                    languagePredicate,
                    authorPredicate,
                    organizationPredicate,
                    getPredicateForTags(root, cq, cb, tags),
                )
            }
        }
            .distinctBy { it.requiredId() }

        val userIds = metadataList.map { it.user.requiredId() }
        val userInfos = userRepository.findAllById(userIds)
        val tagMap = metadataList.toTagMap()
        return metadataList.map { metadata -> metadata to tagMap[metadata].orEmpty() }
            .map { (metadata, tags) ->
                val correspondingUserInfo =
                        userInfos.find { user -> user.id == metadata.user.requiredId() }?.toUserInfo()
                metadata.toDto().toVulnerabilityDto().copy(
                    userInfo = correspondingUserInfo ?: UserInfo(name = "?"),
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    fun getVulnerabilityWithDescriptionByIdentifier(name: String): Mono<VulnerabilityDto> = cosvRepository.findLatestRawExt(name)
        .blockingMap { rawCosvExt ->
            rawCosvExt to lnkCosvMetadataTagRepository.findAllByVulnerabilityMetadataIdentifier(rawCosvExt.metadata.identifier)
        }
        .map { (rawCostExt, tags) ->
            rawCostExt.toVulnerabilityDtoWithDescription()
                .copy(
                    dates = rawCostExt.cosv.getTimeline(),
                    participants = rawCostExt.saveContributors,
                    userInfo = rawCostExt.metadata.user,
                    tags = tags.map { it.tag.name }.toSet(),
                )
        }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     * @return saved [VulnerabilityMetadataDto]
     */
    @Suppress("TOO_LONG_FUNCTION")
    @Transactional
    fun save(
        vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ): Mono<VulnerabilityMetadataDto> = blockingToMono {
        vulnerabilityDto.identifier.ifEmpty {
            val metadata = cosvMetadataRepository.saveAndFlush(
                VulnerabilityMetadata(
                    identifier = "default-${Random.nextInt()}",
                    summary = "STUB",
                    details = "STUB",
                    severityNum = 0f,
                    submitted = getCurrentLocalDateTime().toJavaLocalDateTime(),
                    modified = getCurrentLocalDateTime().toJavaLocalDateTime(),
                    user = userRepository.getByIdOrNotFound(authentication.userId()),
                    organization = null,
                    language = VulnerabilityLanguage.OTHER,
                    status = VulnerabilityStatus.PENDING_REVIEW,
                )
            )
            val newName = "SOTV-${getCurrentLocalDateTime().year}-${metadata.requiredId()}"
            cosvMetadataRepository.save(metadata.apply {
                identifier = newName
            })
            newName
        }
    }
        .flatMap { identifier ->
            cosvService.generateAndSave(
                vulnerabilityDto.copy(
                    identifier = identifier,
                    userInfo = UserInfo(authentication.name),
                )
            )
        }
        .blockingMap { metadataDto ->
            val metadata = cosvMetadataRepository.findByIdentifier(metadataDto.identifier).orNotFound()

            val existedTags = tagRepository.findByNameIn(vulnerabilityDto.tags)
            val existedTagNames = existedTags.map { tag -> tag.name }
            val notFoundTagNames = vulnerabilityDto.tags.filter { it !in existedTagNames }
            val newTags = tagRepository.saveAll(notFoundTagNames.map { Tag(it) })

            vulnerabilityMetadataProjectRepository.saveAll(
                vulnerabilityDto.projects.map { dto -> dto.toEntity(metadata) }
            )

            lnkVulnerabilityMetadataUserRepository.saveAll(
                vulnerabilityDto.participants.map { userDto ->

                    val participant = userRepository.findByName(userDto.name)
                        .orNotFound { "Not found user by name ${userDto.name}" }

                    LnkVulnerabilityMetadataUser(
                        vulnerabilityMetadataId = metadata.requiredId(),
                        user = participant,
                    )
                }
            )

            val tagLinks = existedTags.plus(newTags).map { LnkVulnerabilityMetadataTag(metadata, it) }
            lnkCosvMetadataTagRepository.saveAll(tagLinks)

            metadataDto
        }

    /**
     * @param vulnerabilityDto
     * @param authentication
     * @throws ResponseStatusException
     */
    fun update(vulnerabilityDto: VulnerabilityDto, authentication: Authentication) = blockingToMono {
        val userId = authentication.userId()

        val metadata = cosvMetadataRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()

        // only Super Users and owners of unapproved vuln. can edit it
        if (authentication.hasRole(Role.SUPER_ADMIN) || (userId == metadata.user.requiredId() && metadata.status != VulnerabilityStatus.APPROVED)) {
            val metadataUpdate = metadata.apply {
                status = vulnerabilityDto.status
            }
            cosvMetadataRepository.save(metadataUpdate)
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }.flatMap {
        cosvService.update(vulnerabilityDto.identifier) { cosv ->
            cosv.copy(
                summary = vulnerabilityDto.shortDescription,
                details = vulnerabilityDto.description.orEmpty(),
                severity = cosv.severity?.takeUnless { it.isEmpty() }
                    ?.let { severity ->
                        severity.first().let { entry ->
                            severity.minus(entry).plus(entry.copy(scoreNum = vulnerabilityDto.progress.toString()))
                        }
                    } ?: listOf(
                    vulnerabilityDto.progress.asSeverity()
                )
            ).toMono()
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityIdentifier: String) {
        val metadata = cosvMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.APPROVED
        }
        cosvMetadataRepository.save(metadataUpdate)

        val user = metadata.user
        user.apply {
            rating += VULNERABILITY_OWNER_RATING
        }
        userRepository.save(user)

        metadata.organization?.let { organization ->
            organization.apply { rating += VULNERABILITY_ORGANIZATION_RATING }
            organizationRepository.save(organization)
        }
    }

    /**
     * @param vulnerabilityIdentifier
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityIdentifier: String) {
        val metadata = cosvMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()
        val metadataUpdate = metadata.apply {
            status = VulnerabilityStatus.REJECTED
        }
        cosvMetadataRepository.save(metadataUpdate)
    }

    /**
     * @param name name of vulnerability
     * @throws ResponseStatusException
     */
    fun delete(name: String): Flux<LocalDateTime> = cosvRepository.delete(name)

    /**
     * @param vulnerabilityIdentifier
     * @param authentication
     * @throws ResponseStatusException
     */
    @Transactional
    fun sendToReview(
        vulnerabilityIdentifier: String,
        authentication: Authentication,
    ) {
        val metadata = cosvMetadataRepository.findByIdentifier(vulnerabilityIdentifier).orNotFound()

        if ((authentication.hasRole(Role.SUPER_ADMIN) || authentication.userId() == metadata.user.requiredId()) && metadata.status == VulnerabilityStatus.REJECTED) {
            val metadataUpdate = metadata.apply {
                status = VulnerabilityStatus.PENDING_REVIEW
            }
            cosvMetadataRepository.save(metadataUpdate)
        } else {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }
    }

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return [VulnerabilityDto] with saved [vulnerabilityProjectDtos]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = cosvMetadataRepository.findByIdentifier(vulnerabilityProjectDtos.first().vulnerabilityIdentifier)?.let { metadata ->
        vulnerabilityMetadataProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityMetadataProject(
                    name = dto.name,
                    url = dto.url,
                    versions = dto.versions,
                    type = dto.type,
                    vulnerabilityMetadata = metadata,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @return [Mono] with updated identifier
     */
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
    ): Mono<String> = when (vulnerabilityDateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED -> Mono.error(
            ResponseStatusException(
                HttpStatus.FORBIDDEN,
                "System dates cannot be updated"
            )
        )

        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = vulnerabilityDateDto.date).toMono()
            }

        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = vulnerabilityDateDto.date).toMono()
            }

        else ->
            cosvService.update(vulnerabilityDateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = vulnerabilityDateDto.asTimelineEntry()
                        .let { timelineEntry ->
                            cosv.timeline?.plus(timelineEntry) ?: listOf(timelineEntry)
                        }
                ).toMono()
            }
    }.map { it.identifier }

    /**
     * @param identifier vulnerability identifier
     * @param userName - name of user in vulnerability
     * @return [Mono] with updated identifier
     */
    fun saveUser(
        userName: String,
        identifier: String,
    ): Mono<String> = blockingToMono {
        val user = userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
        cosvMetadataRepository.findByIdentifier(identifier)?.let { metadata ->
            lnkVulnerabilityMetadataUserRepository.save(
                LnkVulnerabilityMetadataUser(
                    vulnerabilityMetadataId = metadata.requiredId(),
                    user = user,
                )
            )
        }
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = user.toUserInfo()
                            .asCredit()
                            .let { credit ->
                                cosv.credits?.plus(credit) ?: listOf(credit)
                            }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param userName name of user
     * @param identifier vulnerability identifier
     * @return [Mono] with updated identifier
     */
    fun deleteUser(userName: String, identifier: String): Mono<String> = blockingToMono {
        val metadata = cosvMetadataRepository.findByIdentifier(identifier).orNotFound { "Not found metadata for vulnerability $identifier" }
        lnkVulnerabilityMetadataUserRepository.deleteByUserNameAndVulnerabilityMetadataId(userName, metadata.requiredId())
    }.flatMap {
        cosvService.update(identifier) { cosv ->
            blockingToMono {
                userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }
            }
                .map { user ->
                    cosv.copy(
                        credits = cosv.credits
                            ?.minus(user.toUserInfo().asCredit())
                            ?.takeUnless { it.isEmpty() }
                    )
                }
        }.map { it.identifier }
    }

    /**
     * @param identifier vulnerability identifier
     * @return list users
     */
    fun getUsers(identifier: String) = cosvMetadataRepository.findByIdentifier(identifier)
        .orNotFound { "Not found metadata for vulnerability $identifier" }
        .let { metadata ->
            lnkVulnerabilityMetadataUserRepository.findByVulnerabilityMetadataId(metadata.requiredId())
                .map { it.user.toUserInfo() }
        }

    /**
     * @param name name of project
     * @param identifier vulnerability identifier
     * @return [Unit]
     */
    @Transactional
    fun deleteProject(
        name: String,
        identifier: String,
    ) = vulnerabilityMetadataProjectRepository.deleteByNameAndVulnerabilityMetadataIdentifier(name, identifier)

    /**
     * @param dateDto [VulnerabilityDateDto] that should be deleted
     * @return [Mono] with vulnerability identifier
     */
    fun deleteDate(dateDto: VulnerabilityDateDto): Mono<String> = when (dateDto.type) {
        VulnerabilityDateType.MODIFIED, VulnerabilityDateType.SUBMITTED -> Mono.error(ResponseStatusException(HttpStatus.FORBIDDEN, "System dates cannot be deleted"))
        VulnerabilityDateType.PUBLISHED ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(published = null).toMono()
            }
        VulnerabilityDateType.WITHDRAWN ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(withdrawn = null).toMono()
            }
        else ->
            cosvService.update(dateDto.vulnerabilityIdentifier) { cosv ->
                cosv.copy(
                    timeline = cosv.timeline?.minus(dateDto.asTimelineEntry())?.takeUnless { it.isEmpty() },
                ).toMono()
            }
    }.map { it.identifier }

    private fun getPredicateForTags(
        root: Root<VulnerabilityMetadata>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        tags: Set<String>
    ): Predicate = if (tags.isEmpty()) {
        cb.and()
    } else {
        val subquery = cq.subquery(Long::class.java)
        val lnkVulnerabilityMetadataTagRoot = subquery.from(LnkVulnerabilityMetadataTag::class.java)
        val tagJoin: Join<LnkVulnerabilityMetadataTag, Tag> = lnkVulnerabilityMetadataTagRoot.join("tag", JoinType.LEFT)

        val cosvMetadataIdPath: Path<Long> = lnkVulnerabilityMetadataTagRoot.get<VulnerabilityMetadata>("vulnerabilityMetadata").get("id")

        subquery.select(cosvMetadataIdPath)
            .where(
                cb.and(
                    tagJoin.get<String>("name").`in`(tags),
                    cb.equal(
                        root.get<Long>("id"),
                        cosvMetadataIdPath,
                    )
                )
            )

        cb.exists(subquery)
    }

    companion object {
        private const val VULNERABILITY_ORGANIZATION_RATING = 10
        private const val VULNERABILITY_OWNER_RATING = 10

        private fun VulnerabilityProjectDto.toEntity(
            metadata: VulnerabilityMetadata,
        ) = VulnerabilityMetadataProject(
            name = name,
            url = url,
            versions = versions,
            type = type,
            vulnerabilityMetadata = metadata,
        )
    }
}
