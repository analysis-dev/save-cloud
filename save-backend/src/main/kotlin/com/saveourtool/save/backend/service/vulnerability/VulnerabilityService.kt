package com.saveourtool.save.backend.service.vulnerability

import com.saveourtool.save.authservice.utils.userId
import com.saveourtool.save.backend.repository.OrganizationRepository
import com.saveourtool.save.backend.repository.TagRepository
import com.saveourtool.save.backend.repository.UserRepository
import com.saveourtool.save.backend.repository.vulnerability.*
import com.saveourtool.save.backend.service.IVulnerabilityService
import com.saveourtool.save.backend.utils.hasRole
import com.saveourtool.save.domain.Role
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.Tag
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.vulnerabilities.*
import com.saveourtool.save.entities.vulnerability.*
import com.saveourtool.save.filters.VulnerabilityFilter
import com.saveourtool.save.info.UserInfo
import com.saveourtool.save.utils.getByIdOrNotFound
import com.saveourtool.save.utils.orNotFound

import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException

import java.time.LocalDateTime
import javax.persistence.criteria.*

import kotlin.random.Random
import kotlinx.datetime.toJavaLocalDateTime

/**
 * A service that provides `Vulnerability`
 */
@Service
@Transactional(readOnly = true)
@Suppress("LongParameterList")
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityProjectRepository: VulnerabilityProjectRepository,
    private val vulnerabilityDateRepository: VulnerabilityDateRepository,
    private val lnkVulnerabilityUserRepository: LnkVulnerabilityUserRepository,
    private val userRepository: UserRepository,
    private val organizationRepository: OrganizationRepository,
    private val lnkVulnerabilityTagRepository: LnkVulnerabilityTagRepository,
    private val tagRepository: TagRepository,
) : IVulnerabilityService {
    @Suppress("TYPE_ALIAS")
    private val getTagMap: List<Vulnerability>.() -> Map<Vulnerability, Set<Tag>> = {
        lnkVulnerabilityTagRepository.findByVulnerabilityIdIn(this.map { it.requiredId() })
            .map { link -> link.vulnerability to link.tag }
            .groupBy { (vulnerability, _) -> vulnerability }
            .mapValues { (_, list) -> list.map { it.second }.toSet() }
    }

    /**
     * @param name name of vulnerability
     * @param status status of vulnerability
     * @return vulnerability by name
     */
    fun findByIdentifierAndStatus(name: String, status: VulnerabilityStatus) = vulnerabilityRepository.findByIdentifierAndStatus(name, status)

    /**
     * @param name name of vulnerability
     * @return vulnerability by name
     */
    override fun findByName(name: String) = vulnerabilityRepository.findByIdentifier(name)

    /**
     * @param userName creator of vulnerability
     * @return list of vulnerabilities
     */
    fun findByUserNameAndStatus(userName: String): List<VulnerabilityDto> {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityRepository.findByUserId(user.requiredId()).map { it.toDto() }
    }

    /**
     * @param userName
     * @param status
     * @return count of vulnerabilities
     */
    fun countByUserNameAndStatus(userName: String, status: VulnerabilityStatus): Int {
        val user = userRepository.findByName(userName).orNotFound {
            "Not found user by name = $userName"
        }
        return vulnerabilityRepository.countByUserIdAndStatus(user.requiredId(), status)
    }

    /**
     * @param organizationName name of organization
     * @param status status of vulnerability
     * @return list of vulnerabilities
     */
    fun findByOrganizationNameAndStatus(organizationName: String, status: VulnerabilityStatus): List<Vulnerability> =
            vulnerabilityRepository.findByOrganizationNameAndStatus(organizationName, status)

    /**
     * @param vulnerabilityId id of vulnerability
     * @return list of vulnerabilities
     */
    fun findUsersByVulnerabilityId(
        vulnerabilityId: Long
    ): List<LnkVulnerabilityUser> = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerabilityId)

    /**
     * @return all vulnerabilities
     */
    fun findAll(): List<Vulnerability> = vulnerabilityRepository.findAll()

    /**
     * @param filters filters for vulnerability
     * @param authentication [Authentication] describing an authenticated request
     * @return list of vulnerabilities with that match [filters]
     */
    @Suppress(
        "TOO_LONG_FUNCTION",
        "LongMethod",
        "CyclomaticComplexMethod",
    )
    fun getFilteredWithUserInfos(
        filters: VulnerabilityFilter,
        authentication: Authentication?,
    ): List<VulnerabilityDto> {
        val vulnerabilities = vulnerabilityRepository.findAll { root, cq, cb ->
            with(filters) {
                val namePredicate = if (identifierPrefix.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("identifier"), "%$identifierPrefix%")
                }

                val ownerPredicate = authentication?.let {
                    val userId = authentication.userId()
                    if (isOwner) {
                        cb.equal(root.get<Vulnerability>("userId"), userId)
                    } else {
                        cb.and()
                    }
                } ?: cb.and()

                val statusPredicate = status?.let { status ->
                    cb.equal(root.get<Vulnerability>("status"), status)
                } ?: cb.and()

                val languagePredicate = language?.let { language ->
                    cb.equal(root.get<Vulnerability>("language"), language)
                } ?: cb.and()

                val organizationPredicate = organizationName?.let { organization ->
                    cb.equal(root.get<Vulnerability>("organization").get<Organization?>("name"), organization)
                } ?: cb.and()

                val authorPredicate = authorName?.let { author ->
                    val subquery: Subquery<Long> = cq.subquery(Long::class.java)
                    val userRoot = subquery.from(User::class.java)

                    subquery.select(userRoot.get("id")).where(cb.equal(userRoot.get<String>("name"), author))

                    cb.`in`(root.get<Long>("userId")).value(subquery)
                } ?: cb.and()

                cb.and(
                    namePredicate,
                    ownerPredicate,
                    statusPredicate,
                    languagePredicate,
                    authorPredicate,
                    organizationPredicate,
                    getPredicateForTags(root, cq, cb, tags),
                )
            }
        }
            .distinctBy { it.requiredId() }

        val userIds = vulnerabilities.map { it.userId }
        val userInfos = userRepository.findAllById(userIds)
        val tagMap = vulnerabilities.getTagMap()
        return vulnerabilities.map { vulnerability -> vulnerability to tagMap[vulnerability].orEmpty() }
            .map { (vulnerability, tags) ->
                val correspondingUserInfo = userInfos.find { user -> user.id == vulnerability.userId }?.toUserInfo()
                vulnerability.toDto().copy(
                    userInfo = correspondingUserInfo ?: UserInfo(name = "?"),
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param filters
     * @return list of vulnerabilities with that match [filters]
     */
    @Suppress("WRONG_OVERLOADING_FUNCTION_ARGUMENTS", "TOO_LONG_FUNCTION")
    fun getFilteredWithUserInfos(
        filters: VulnerabilityFilter,
    ): List<VulnerabilityDto> {
        val vulnerabilities = vulnerabilityRepository.findAll { root, cq, cb ->
            with(filters) {
                val namePredicate = if (identifierPrefix.isBlank()) {
                    cb.and()
                } else {
                    cb.like(root.get("identifier"), "%$identifierPrefix%")
                }

                cb.and(
                    namePredicate,
                    getPredicateForTags(root, cq, cb, tags),
                    cb.equal(root.get<Vulnerability>("status"), status),
                )
            }
        }
            .distinctBy { it.requiredId() }

        val userIds = vulnerabilities.map { it.userId }
        val userInfos = userRepository.findAllById(userIds)
        val tagMap = vulnerabilities.getTagMap()
        return vulnerabilities.map { vulnerability -> vulnerability to tagMap[vulnerability].orEmpty() }
            .map { (vulnerability, tags) ->
                val correspondingUserInfo = userInfos.find { user -> user.id == vulnerability.userId }?.toUserInfo()
                vulnerability.toDto().copy(
                    userInfo = correspondingUserInfo ?: UserInfo(name = "?"),
                    tags = tags.map { it.name }.toSet(),
                )
            }
    }

    /**
     * @param name name of vulnerability
     * @return vulnerability dto by name with description
     */
    @Transactional
    fun getVulnerabilityWithDescriptionByIdentifier(name: String): VulnerabilityDto? {
        val vulnerability = vulnerabilityRepository.findByIdentifier(name).orNotFound {
            "Not found vulnerability by identifier $name"
        }
        val dates = vulnerabilityDateRepository.findByVulnerabilityIdentifier(name).map { it.toDto() }
        val users = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerability.requiredId()).map { it.user.toUserInfo() }
        val authorUserInfo = userRepository.getByIdOrNotFound(vulnerability.userId).toUserInfo()
        val tags = lnkVulnerabilityTagRepository.findByVulnerabilityId(vulnerability.requiredId())
            .map { it.tag.name }
            .toSet()

        return vulnerability.toDtoWithDescription().copy(
            dates = dates,
            participants = users,
            userInfo = authorUserInfo,
            tags = tags,
        )
    }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     * @return saved [Vulnerability]
     */
    @Suppress("TOO_LONG_FUNCTION")
    @Transactional
    fun save(
        vulnerabilityDto: VulnerabilityDto,
        authentication: Authentication,
    ): Vulnerability {
        val userId = authentication.userId()
        val user = userRepository.getByIdOrNotFound(userId)
        return save(vulnerabilityDto, user)
    }

    /**
     * @param vulnerabilityDto dto of new vulnerability
     * @param authentication auth info of a current user
     * @return saved [Vulnerability]
     */
    @Suppress("TOO_LONG_FUNCTION")
    @Transactional
    override fun save(
        vulnerabilityDto: VulnerabilityDto,
        user: User,
    ): Vulnerability {
        val organizationNew = vulnerabilityDto.organization?.name?.let { organizationRepository.findByName(it) }

        val vulnerabilityIdentifier = vulnerabilityDto.identifier.ifEmpty { "default-${Random.nextInt()}" }

        val vulnerability = Vulnerability(
            identifier = vulnerabilityIdentifier,
            description = vulnerabilityDto.description.orEmpty(),
            shortDescription = vulnerabilityDto.shortDescription,
            relatedLink = vulnerabilityDto.relatedLink,
            language = vulnerabilityDto.language,
            progress = vulnerabilityDto.progress,
            projects = emptyList(),
            status = VulnerabilityStatus.CREATED,
            userId = user.requiredId(),
            organization = organizationNew,
        )
        val vulnerabilityNew = vulnerabilityRepository.saveAndFlush(vulnerability)
        val newName = vulnerabilityDto.identifier.ifEmpty { "SOTV-${LocalDateTime.now().year}-${vulnerabilityNew.id}" }

        val existedTags = tagRepository.findByNameIn(vulnerabilityDto.tags)
        val existedTagNames = existedTags.map { tag -> tag.name }
        val notFoundTagNames = vulnerabilityDto.tags.filter { it !in existedTagNames }
        val newTags = tagRepository.saveAll(notFoundTagNames.map { Tag(it) })

        vulnerabilityRepository.save(
            vulnerabilityNew.apply {
                identifier = newName
                projects = vulnerabilityDto.projects.map { dto -> dto.toEntity(vulnerabilityNew) }
            }
        )

        vulnerabilityDateRepository.saveAll(
            vulnerabilityDto.dates.map { dto -> dto.toEntity(vulnerabilityNew, user) }
        )

        lnkVulnerabilityUserRepository.saveAll(
            vulnerabilityDto.participants.map { userDto ->

                val participant = userRepository.findByName(userDto.name).orNotFound { "Not found user by name ${userDto.name}" }

                LnkVulnerabilityUser(
                    vulnerabilityId = vulnerabilityNew.requiredId(),
                    user = participant,
                )
            }
        )

        val vulnTagLinks = existedTags.plus(newTags).map { LnkVulnerabilityTag(vulnerability, it) }
        lnkVulnerabilityTagRepository.saveAll(vulnTagLinks)

        return vulnerabilityNew
    }

    /**
     * @param vulnerabilityDtos dtos of new vulnerabilities
     * @param authentication auth info of a current user
     */
    fun saveAll(
        vulnerabilityDtos: List<VulnerabilityDto>,
        authentication: Authentication,
    ) {
        vulnerabilityDtos.map { dto -> save(dto, authentication) }
    }

    /**
     * @param vulnerabilityDto
     * @param authentication
     * @throws ResponseStatusException
     */
    @Transactional
    fun update(vulnerabilityDto: VulnerabilityDto, authentication: Authentication) {
        val userId = authentication.userId()

        val vulnerability = vulnerabilityRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()

        if (!authentication.hasRole(Role.SUPER_ADMIN) && (userId != vulnerability.userId || vulnerability.status == VulnerabilityStatus.APPROVED)) {
            throw ResponseStatusException(HttpStatus.FORBIDDEN)
        }

        val vulnerabilityUpdate = vulnerability.apply {
            progress = vulnerabilityDto.progress
            description = vulnerabilityDto.description.orEmpty()
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun approve(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)

        val user = userRepository.getByIdOrNotFound(vulnerability.userId)
        user.apply {
            rating += VULNERABILITY_OWNER_RATING
        }
        userRepository.save(user)

        vulnerabilityDto.organization?.name?.let { organizationName ->
            val organizationNew = organizationRepository.findByName(organizationName)
                .orNotFound { "Not found organization by name = $organizationName" }
            organizationNew.apply { rating += VULNERABILITY_ORGANIZATION_RATING }
            organizationRepository.save(organizationNew)
        }
    }

    /**
     * @param vulnerabilityDto
     * @throws ResponseStatusException
     */
    @Transactional
    fun reject(vulnerabilityDto: VulnerabilityDto) {
        val vulnerability = vulnerabilityRepository.findByIdentifier(vulnerabilityDto.identifier).orNotFound()
        val vulnerabilityUpdate = vulnerability.apply {
            status = vulnerabilityDto.status
        }
        vulnerabilityRepository.save(vulnerabilityUpdate)
    }

    /**
     * @param name name of vulnerability
     * @throws ResponseStatusException
     */
    @Transactional
    fun delete(name: String) {
        val vulnerability = vulnerabilityRepository.findByIdentifier(name).orNotFound()
        vulnerabilityRepository.delete(vulnerability)
    }

    /**
     * @param vulnerabilityProjectDtos dto list of vulnerability projects
     * @return [VulnerabilityDto] with saved [vulnerabilityProjectDtos]
     */
    @Transactional
    fun saveAllProjects(
        vulnerabilityProjectDtos: List<VulnerabilityProjectDto>
    ): List<VulnerabilityProjectDto>? = vulnerabilityRepository.findByIdentifier(vulnerabilityProjectDtos.first().vulnerabilityIdentifier)?.let { vulnerability ->
        vulnerabilityProjectRepository.saveAll(
            vulnerabilityProjectDtos.map { dto ->
                VulnerabilityProject(
                    name = dto.name,
                    url = dto.url,
                    versions = dto.versions,
                    type = dto.type,
                    vulnerability = vulnerability,
                )
            }
        )
            .map { it.toDto() }
    }

    /**
     * @param vulnerabilityDateDto dto of vulnerability date
     * @param authentication - auth info of a current user
     */
    @Transactional
    fun saveDate(
        vulnerabilityDateDto: VulnerabilityDateDto,
        authentication: Authentication,
    ) {
        val userId = authentication.userId()
        val user = userRepository.getByIdOrNotFound(userId)

        vulnerabilityRepository.findByIdentifier(vulnerabilityDateDto.vulnerabilityIdentifier)?.let { vulnerability ->
            vulnerabilityDateRepository.save(
                vulnerabilityDateDto.let { dto ->
                    VulnerabilityDate(
                        date = dto.date.toJavaLocalDateTime(),
                        type = dto.type,
                        vulnerability = vulnerability,
                        userId = user.requiredId(),
                    )
                }
            )
        }
    }

    /**
     * @param identifier vulnerability identifier
     * @param userName - name of user in vulnerability
     */
    @Transactional
    fun saveUser(
        userName: String,
        identifier: String,
    ) {
        val user = userRepository.findByName(userName).orNotFound { "Not found user by name $userName" }

        vulnerabilityRepository.findByIdentifier(identifier)?.let { vulnerability ->
            lnkVulnerabilityUserRepository.save(
                LnkVulnerabilityUser(
                    vulnerabilityId = vulnerability.requiredId(),
                    user = user,
                )
            )
        }
    }

    /**
     * @param userName name of user
     * @param identifier vulnerability identifier
     */
    @Transactional
    fun deleteUser(userName: String, identifier: String) {
        val vulnerability = vulnerabilityRepository.findByIdentifier(identifier).orNotFound { "Not found user by vulnerability $identifier" }
        lnkVulnerabilityUserRepository.deleteByUserNameAndVulnerabilityId(userName, vulnerability.requiredId())
    }

    /**
     * @param vulnerabilityId
     * @return list users
     */
    fun getUsers(vulnerabilityId: Long) = lnkVulnerabilityUserRepository.findByVulnerabilityId(vulnerabilityId)

    /**
     * @param name name of project
     * @param identifier vulnerability identifier
     * @return updated [Vulnerability]
     */
    @Transactional
    fun deleteProject(
        name: String,
        identifier: String,
    ) = vulnerabilityProjectRepository.deleteByNameAndVulnerabilityIdentifier(name, identifier)

    /**
     * @param dateDto [VulnerabilityDateDto] that corresponds with [VulnerabilityDate] that should be deleted
     * @return [Unit]
     */
    @Transactional
    fun deleteDate(dateDto: VulnerabilityDateDto) = vulnerabilityDateRepository.findByVulnerabilityIdentifierAndType(
        dateDto.vulnerabilityIdentifier,
        dateDto.type
    )
        .orNotFound { "Could not find date for ${dateDto.vulnerabilityIdentifier} of type ${dateDto.type} (${dateDto.date})." }
        .let { vulnerabilityDateRepository.delete(it) }

    private fun getPredicateForTags(
        root: Root<Vulnerability>,
        cq: CriteriaQuery<*>,
        cb: CriteriaBuilder,
        tags: Set<String>
    ): Predicate = if (tags.isEmpty()) {
        cb.and()
    } else {
        val subquery = cq.subquery(Long::class.java)
        val lnkVulnerabilityTagRoot = subquery.from(LnkVulnerabilityTag::class.java)
        val tagJoin: Join<LnkVulnerabilityTag, Tag> = lnkVulnerabilityTagRoot.join("tag", JoinType.LEFT)

        val vulnerabilityIdPath: Path<Long> = lnkVulnerabilityTagRoot.get<Vulnerability>("vulnerability").get("id")

        subquery.select(vulnerabilityIdPath)
            .where(
                cb.and(
                    tagJoin.get<String>("name").`in`(tags),
                    cb.equal(
                        root.get<Long>("id"),
                        vulnerabilityIdPath,
                    )
                )
            )

        cb.exists(subquery)
    }

    companion object {
        private const val VULNERABILITY_ORGANIZATION_RATING = 10
        private const val VULNERABILITY_OWNER_RATING = 10

        private fun VulnerabilityProjectDto.toEntity(
            vulnerability: Vulnerability,
        ) = VulnerabilityProject(
            name = name,
            url = url,
            versions = versions,
            type = type,
            vulnerability = vulnerability,
        )

        private fun VulnerabilityDateDto.toEntity(
            vulnerability: Vulnerability,
            user: User,
        ) = VulnerabilityDate(
            date = date.toJavaLocalDateTime(),
            type = type,
            vulnerability = vulnerability,
            userId = user.requiredId(),
        )
    }
}
