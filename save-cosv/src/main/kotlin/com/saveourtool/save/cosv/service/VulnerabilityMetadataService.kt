package com.saveourtool.save.cosv.service

import com.saveourtool.save.cosv.repository.AnyCosvSchema
import com.saveourtool.save.cosv.repository.CosvSchema
import com.saveourtool.save.cosv.repository.VulnerabilityMetadataRepository
import com.saveourtool.save.cosv.storage.CosvFileS3KeyManager
import com.saveourtool.save.cvsscalculator.calculateBaseScore
import com.saveourtool.save.entities.Organization
import com.saveourtool.save.entities.User
import com.saveourtool.save.entities.cosv.CosvFile
import com.saveourtool.save.entities.cosv.VulnerabilityMetadata
import com.saveourtool.save.entities.cosv.VulnerabilityMetadataDto
import com.saveourtool.save.entities.cosv.VulnerabilityMetadataDto.Companion.SUMMARY_LENGTH
import com.saveourtool.save.entities.vulnerability.VulnerabilityLanguage
import com.saveourtool.save.entities.vulnerability.VulnerabilityStatus
import com.saveourtool.save.utils.ELLIPSIS
import com.saveourtool.save.utils.getCurrentLocalDateTime
import com.saveourtool.save.utils.getLanguage
import com.saveourtool.save.utils.getLogger
import com.saveourtool.save.utils.shorten
import com.saveourtool.save.utils.warn

import com.saveourtool.osv4k.Severity
import com.saveourtool.osv4k.SeverityType
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException

import kotlinx.datetime.toJavaLocalDateTime

/**
 * Service for [VulnerabilityMetadata]
 */
@Service
class VulnerabilityMetadataService(
    private val vulnerabilityMetadataRepository: VulnerabilityMetadataRepository,
    private val cosvFileS3KeyManager: CosvFileS3KeyManager,
) {
    /**
     * @param cosvFile
     * @param cosv
     * @param user
     * @param organization
     * @param isAutoApprove
     * @return updated [VulnerabilityMetadata]
     */
    @Transactional
    fun createOrUpdate(
        cosvFile: CosvFile,
        cosv: AnyCosvSchema,
        user: User,
        organization: Organization?,
        isAutoApprove: Boolean,
    ): VulnerabilityMetadata {
        val metadata = vulnerabilityMetadataRepository.findByIdentifier(cosv.id)
            ?.let { existedMetadata ->
                validateMetadata(existedMetadata, cosv, user, organization)
                cosvFileS3KeyManager.setPrevCosvFile(cosvFile, existedMetadata)
                existedMetadata.updateBy(cosv, cosvFile, isAutoApprove)
            }
            ?: run {
                cosv.toNewMetadata(user, organization, cosvFile, isAutoApprove)
            }

        return vulnerabilityMetadataRepository.save(metadata)
    }

    /**
     * @param identifier
     * @return [VulnerabilityMetadata] for [identifier]
     */
    fun findByIdentifier(
        identifier: String,
    ): VulnerabilityMetadata? = vulnerabilityMetadataRepository.findByIdentifier(identifier)

    companion object {
        @Suppress("GENERIC_VARIABLE_WRONG_DECLARATION")
        private val logger = getLogger<VulnerabilityMetadataService>()

        /**
         * Should not exceed [VulnerabilityMetadataDto.SUMMARY_LENGTH].
         */
        private const val SUMMARY_LENGTH_FROM_DETAILS = 35

        private fun CosvSchema<*, *, *, *>.toNewMetadata(
            user: User,
            organization: Organization?,
            cosvFile: CosvFile,
            isAutoApprove: Boolean,
        ) = VulnerabilityMetadata(
            identifier = id,
            summary = summary ?: details?.take(SUMMARY_LENGTH_FROM_DETAILS)?.let { "$it ..." } ?: "Summary not provided",
            details = details ?: "Details not provided",
            severityNum = getSeverityNumber(),
            modified = modified.toJavaLocalDateTime(),
            submitted = getCurrentLocalDateTime().toJavaLocalDateTime(),
            user = user,
            organization = organization,
            language = getLanguage() ?: VulnerabilityLanguage.OTHER,
            status = isAutoApprove.toVulnerabilityStatus(),
            latestCosvFile = cosvFile,
        )

        private fun getScore(severity: Severity): Float {
            val score = calculateBaseScore(severity.score)
            severity.scoreNum?.let { scoreNum ->
                if (score != scoreNum.toFloat()) {
                    logger.warn {
                        "Score num $scoreNum from osv file is not equal to the calculated value from the base score vector $score."
                    }
                }
            }
            return score
        }

        @Suppress("ThrowsCount")
        private fun validateMetadata(
            existedMetadata: VulnerabilityMetadata,
            cosv: CosvSchema<*, *, *, *>,
            user: User,
            organization: Organization?,
        ) {
            val newModified = cosv.modified.toJavaLocalDateTime()
            val errorPrefix: () -> String = {
                "Failed to upload COSV [${cosv.id}/${cosv.modified}]"
            }
            when {
                existedMetadata.modified >= newModified -> throw ResponseStatusException(
                    HttpStatus.BAD_REQUEST,
                    "${errorPrefix()}: existed entry has newer version (${existedMetadata.modified})",
                )
                existedMetadata.user.requiredId() != user.requiredId() -> throw ResponseStatusException(
                    HttpStatus.FORBIDDEN,
                    "${errorPrefix()} by userId=${user.requiredId()}: " +
                            "already existed in save uploaded by another userId=${existedMetadata.user.requiredId()}",
                )
                else -> existedMetadata.organization?.run {
                    if (requiredId() != organization?.requiredId()) {
                        throw ResponseStatusException(
                            HttpStatus.FORBIDDEN,
                            "${errorPrefix()} to organizationId=${requiredId()}: " +
                                    "already existed in save in another organizationId=${existedMetadata.organization?.requiredId()}",
                        )
                    }
                }
            }
        }

        private fun VulnerabilityMetadata.updateBy(
            entry: CosvSchema<*, *, *, *>,
            cosvFile: CosvFile,
            isAutoApprove: Boolean,
        ): VulnerabilityMetadata = apply {
            summary = entry.summary?.shorten(SUMMARY_LENGTH) ?: entry.details?.take(SUMMARY_LENGTH_FROM_DETAILS)?.let { "$it$ELLIPSIS" } ?: "Summary not provided"
            details = entry.details ?: "Details not provided"
            severityNum = entry.getSeverityNumber()
            modified = entry.modified.toJavaLocalDateTime()
            latestCosvFile = cosvFile
            status = isAutoApprove.toVulnerabilityStatus()
        }

        private fun CosvSchema<*, *, *, *>.getSeverityNumber() =
                severity?.find { it.type == SeverityType.CVSS_V3 }?.let {
                    getScore(it)
                } ?: severity?.find { it.type == SeverityType.CVSS_V2 }?.let {
                    getScore(it)
                } ?: 0f

        private fun Boolean.toVulnerabilityStatus() = if (this) VulnerabilityStatus.AUTO_APPROVED else VulnerabilityStatus.PENDING_REVIEW
    }
}
